<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","width":280,"display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":20},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Widget, Element, RanderObject 三者之间的关系">
<meta name="keywords" content="Flutter">
<meta property="og:type" content="article">
<meta property="og:title" content="flutter ui源码 初步">
<meta property="og:url" content="http://yoursite.com/2020/08/14/Flutter/flutter-ui源码-初步/index.html">
<meta property="og:site_name" content="BrightStone">
<meta property="og:description" content="Widget, Element, RanderObject 三者之间的关系">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-09-26T08:04:26.065Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="flutter ui源码 初步">
<meta name="twitter:description" content="Widget, Element, RanderObject 三者之间的关系">

<link rel="canonical" href="http://yoursite.com/2020/08/14/Flutter/flutter-ui源码-初步/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>flutter ui源码 初步 | BrightStone</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BrightStone</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/14/Flutter/flutter-ui源码-初步/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BrightStone">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BrightStone">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          flutter ui源码 初步
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-14 20:30:42" itemprop="dateCreated datePublished" datetime="2020-08-14T20:30:42+08:00">2020-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-26 16:04:26" itemprop="dateModified" datetime="2020-09-26T16:04:26+08:00">2020-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Widget-Element-RanderObject-三者之间的关系"><a href="#Widget-Element-RanderObject-三者之间的关系" class="headerlink" title="Widget, Element, RanderObject 三者之间的关系"></a>Widget, Element, RanderObject 三者之间的关系</h2><a id="more"></a><p>Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。</p>
<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>Widget类和Element类一一对应。Element是通过Widget生成的<br>Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。</p>
<p><strong>Widget.createElement()</strong></p>
<p>创建Element对象</p>
<p><strong>Widget.canUpdate(..)</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；<br>通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.</p>
<p><strong>createState()</strong></p>
<p>用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，<strong>所以，本质上就是一个StatefulElement对应一个State实例。</strong></p>
<p><strong>widget和context</strong></p>
<ul>
<li><p>widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但<strong>State实例只会在第一次插入到树中时被创建</strong>，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 </p>
</li>
<li><p>context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext</p>
</li>
</ul>
<p><strong>State如何被Widget复用</strong><br>只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。</p>
<h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>
<p>下面从Element的 <strong>挂载、更新、卸载</strong>过程来描述Element</p>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p><strong>根Element的mount</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- main() </span><br><span class="line">    - runApp(..)</span><br><span class="line">    - WidgetsFlutterBinding.attachRootWidget(app)</span><br><span class="line">        - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">            - createElement()</span><br><span class="line">            - BuildOwner.buildScope(element, () &#123;</span><br><span class="line">                element.mount(null, null);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<p>以上是根Element的mount过程，其中rederViewElement是根Elemet</p>
<p>** Element的mount过程</p>
<p>首先来看一下常用的StatelessElement，StatefulElement的继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element -&gt; ComponentElement -&gt; StatelessElement</span><br><span class="line">                            -&gt; StatefulElement</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- mount()</span><br><span class="line">    - Element.updateInheritance()</span><br><span class="line">    - ComponentElement.firstBuild()</span><br><span class="line">        - Element.rebuild()</span><br><span class="line">        - ComponentElement.performRebuild()</span><br><span class="line">            - built = build()</span><br><span class="line">                -Widget.build()</span><br><span class="line">            - Element.updateChild(child, built, _)</span><br></pre></td></tr></table></figure>
<p>Element.updateChild方法非常重要</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">      deactivateChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inflateWidget(newWidget, newSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的代码，总结各种case</p>
<ul>
<li>child != null &amp;&amp; newWidget == null :<br>  newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element</li>
<li>child == null &amp;&amp; newWidget != null :<br>  第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)</li>
<li>child != null &amp;&amp; newWidget != null :<br>  更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建</li>
<li>child == null &amp;&amp; newWidget == null :<br>  do nothing</li>
</ul>
<p>在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">    newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  State createState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  StatefulElement(StatefulWidget widget)</span><br><span class="line">      : _state = widget.createState(),</span><br><span class="line">        <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">    _state._element = <span class="keyword">this</span>;</span><br><span class="line">    _state._widget = widget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; state.build(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StatefulWidget，State，StatefulElement的调用关系：<br>Widget.createElement() -&gt; Element.build() -&gt; State.build()</p>
<h3 id="更新Element"><a href="#更新Element" class="headerlink" title="更新Element"></a>更新Element</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget.setState</span><br><span class="line">    - <span class="built_in">Element</span>.markNeedsBuild()</span><br><span class="line">        - <span class="built_in">Element</span>._dirty = <span class="keyword">true</span></span><br><span class="line">        - BuildOwner.scheduleBuildFor(<span class="keyword">this</span>)</span><br><span class="line">            - BuildOwner._dirtyElements.add(element)</span><br></pre></td></tr></table></figure>
<p>当调用statState之后，会将element标脏，并加入到_dirtyElements列表中</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- WidgetsBinding.drawFrame()</span><br><span class="line">    - BuildOwner.buildScope(renderViewElement)</span><br><span class="line">        - BuildOwner._dirtyElements[index].rebuild()</span><br></pre></td></tr></table></figure>
<p>每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。<br>可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的</p>
<h3 id="卸载Element"><a href="#卸载Element" class="headerlink" title="卸载Element"></a>卸载Element</h3><p>在Element的updateChild方法中，在 <code>child != null &amp;&amp; newWidget == null</code> 时，会调用deactivateChild()</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">  child._parent = <span class="keyword">null</span>;</span><br><span class="line">  child.detachRenderObject();</span><br><span class="line">  owner._inactiveElements.add(child); <span class="comment">// this eventually calls child.deactivate()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。</p>
<p>还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> finalizeTree() &#123;</span><br><span class="line">    Timeline.startSync(<span class="string">'Finalize tree'</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lockState(() &#123;</span><br><span class="line">        _inactiveElements._unmountAll(); <span class="comment">// this unregisters the GlobalKeys</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _unmountAll() &#123;</span><br><span class="line">    _locked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; elements = _elements.toList()..sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    _elements.clear();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      elements.reversed.forEach(_unmount);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _unmount(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    element.visitChildren((<span class="built_in">Element</span> child) &#123;</span><br><span class="line">      _unmount(child);</span><br><span class="line">    &#125;);</span><br><span class="line">    element.unmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h2><h3 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><p>RenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。<strong>不是所有的Element都有对应的RenderObject</strong></p>
<p>RenderObjectElement有三个常用的子类：</p>
<ul>
<li>LeafRenderObjectElement：Leaf render objects, with no children</li>
<li>SingleChildRenderObjectElement：A single child</li>
<li>MultiChildRenderObjectElement：A linked list of children.</li>
</ul>
<p>RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。</p>
<p><strong>mmount、update、unmount</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">  <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">  <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">    _updateParentData(parentDataElement.widget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RenderObject的更新"><a href="#RenderObject的更新" class="headerlink" title="RenderObject的更新"></a>RenderObject的更新</h3><p>我们从render树的insert过程类分析RenderObject的更新<br>从RenderObjectElement.insertChildRenderObject开始</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> insertChildRenderObject(RenderObject child, <span class="built_in">Element</span> slot) &#123;</span><br><span class="line">  <span class="keyword">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class="keyword">this</span>.renderObject;</span><br><span class="line">  renderObject.insert(child, after: slot?.renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了ContainerRenderObjectMixin的insert方法，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> insert(ChildType child, &#123; ChildType after &#125;) &#123;</span><br><span class="line">  adoptChild(child);</span><br><span class="line">  _insertIntoChildList(child, after: after);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> adoptChild(RenderObject child) &#123;</span><br><span class="line">  setupParentData(child);</span><br><span class="line">  markNeedsLayout();</span><br><span class="line">  markNeedsCompositingBitsUpdate();</span><br><span class="line">  markNeedsSemanticsUpdate();</span><br><span class="line">  <span class="keyword">super</span>.adoptChild(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> markParentNeedsLayout() &#123;</span><br><span class="line">  _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">  <span class="keyword">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class="line">    parent.markNeedsLayout();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent._debugDoingThisLayout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和element的build流程不同，RenderObject的标脏会向上标脏。<br>找到 _relayoutBoundary 节点，触发<code>owner._nodesNeedingLayout.add( this )</code>与<code>owner.requestVisualUpdate()</code> 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner</p>
<p>PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。<br>(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)<br>来看一下PiplelineOwner.requestVisualUpdate</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> requestVisualUpdate() &#123;</span><br><span class="line">  <span class="keyword">if</span> (onNeedVisualUpdate != <span class="keyword">null</span>)</span><br><span class="line">    onNeedVisualUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initInstances();</span><br><span class="line">  _instance = <span class="keyword">this</span>;</span><br><span class="line">  _pipelineOwner = PipelineOwner(</span><br><span class="line">    onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">window</span></span><br><span class="line">    ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">    ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">    ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">    ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">    ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">  initRenderView();</span><br><span class="line">  _handleSemanticsEnabledChanged();</span><br><span class="line">  <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">  addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">  initMouseTracker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _handlePersistentFrameCallback(<span class="built_in">Duration</span> timeStamp) &#123;</span><br><span class="line">  drawFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制</p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p><strong>RendererBinding.drawFrame</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  ...</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pipelineOwner.flushLayout()</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">      <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">          node._layoutWithoutResize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>*RendererObject._layoutWithoutResize</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'performLayout'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用performLayout()进行layout，并标记需要paint</p>
<h3 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h3><p>之前说到过，layout过程中会对paint进行标脏</p>
<p><strong>markNeedsPaint()</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsPaint)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If we're the root of the render tree (probably a RenderView),</span></span><br><span class="line">    <span class="comment">// then we have to paint ourselves, since nobody else can paint</span></span><br><span class="line">    <span class="comment">// us. We don't add ourselves to _nodesNeedingPaint in this</span></span><br><span class="line">    <span class="comment">// case, because the root is always told to paint regardless.</span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。<strong>注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的</strong><br>需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。</p>
<p><strong>pipelineOwner.flushLayout()</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">    <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._layer.attached) &#123;</span><br><span class="line">          PaintingContext.repaintCompositedChild(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          node._skippedPaintingOnLayer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 <code>node._layer.attached</code>, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 <code>node._skippedPaintingOnLayer();</code></p>
<p><strong>node._skippedPaintingOnLayer()</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _skippedPaintingOnLayer() &#123;</span><br><span class="line">  AbstractNode ancestor = parent;</span><br><span class="line">  <span class="keyword">while</span> (ancestor <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject node = ancestor;</span><br><span class="line">    <span class="keyword">if</span> (node.isRepaintBoundary) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._layer == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// looks like the subtree here has never been painted. let it handle itself.</span></span><br><span class="line">      <span class="keyword">if</span> (node._layer.attached)</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// it's the one that detached us, so it's the one that will decide to repaint us.</span></span><br><span class="line">      node._needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ancestor = node.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 </p>
<p><strong>PaintingContext.repaintCompositedChild(node);</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> repaintCompositedChild(RenderObject child, &#123; <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  _repaintCompositedChild(</span><br><span class="line">    child,</span><br><span class="line">    debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">  RenderObject child, &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">  PaintingContext childContext,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  OffsetLayer childLayer = child._layer;</span><br><span class="line">  <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    child._layer = childLayer = OffsetLayer();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    childLayer.removeAllChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">  child._paintWithContext(childContext, Offset.zero);</span><br><span class="line"></span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 <code>child._paintWithContext(childContext, Offset.zero);</code>中</p>
<p><strong>child._paintWithContext(childContext, Offset.zero);</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="comment">// 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。</span></span><br><span class="line">  <span class="comment">// 英文注释没咋看懂</span></span><br><span class="line">  <span class="keyword">if</span> (_needsLayout)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  RenderObject debugLastActivePaint;</span><br><span class="line">  _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 最终的重绘交给具体的 RenderObject 子类</span></span><br><span class="line">    paint(context, offset);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'paint'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Flutter/" rel="tag"># Flutter</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2020/07/23/Java/Java获取泛型类型/" rel="next" title="Java获取泛型类型">
                  <i class="fa fa-chevron-left"></i> Java获取泛型类型
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2020/09/22/Flutter/RenderObject-原理/" rel="prev" title="RenderObject 原理">
                  RenderObject 原理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Widget-Element-RanderObject-三者之间的关系"><span class="nav-text">Widget, Element, RanderObject 三者之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Widget"><span class="nav-text">Widget</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#State"><span class="nav-text">State</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Element"><span class="nav-text">Element</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mount"><span class="nav-text">mount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新Element"><span class="nav-text">更新Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卸载Element"><span class="nav-text">卸载Element</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RenderObject"><span class="nav-text">RenderObject</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RenderObjectElement"><span class="nav-text">RenderObjectElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RenderObject的更新"><span class="nav-text">RenderObject的更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#layout"><span class="nav-text">layout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#paint"><span class="nav-text">paint</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="BrightStone" src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">BrightStone</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BrightStone</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

</body>
</html>
