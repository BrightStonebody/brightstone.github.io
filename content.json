{"meta":{"title":"BrightStone","subtitle":null,"description":null,"author":"BrightStone","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-12-21T12:16:41.881Z","updated":"2019-12-21T12:16:41.881Z","comments":true,"path":"notes/boostnote.json","permalink":"http://yoursite.com/notes/boostnote.json","excerpt":"","text":""},{"title":"categories","date":"2019-04-13T04:54:42.000Z","updated":"2019-12-21T12:16:41.880Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-14T12:06:37.000Z","updated":"2019-12-21T12:16:41.881Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ViewDragHelper的使用","slug":"Android/ViewDragHelper的使用","date":"2020-02-19T02:36:30.000Z","updated":"2020-02-19T03:16:02.710Z","comments":true,"path":"2020/02/19/Android/ViewDragHelper的使用/","link":"","permalink":"http://yoursite.com/2020/02/19/Android/ViewDragHelper的使用/","excerpt":"ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部","text":"ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部 参考 ViewDragHelper 的基本使用 常用Api初始化 1public static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb) 第一个参数是父布局, 第二个参数是自定义的监听回调 拦截事件 在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断 123456789101112@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; //ViewDragHelper对事件进行拦截 return mViewDragHelper.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //将事件传递给ViewDragHelper进行处理 mViewDragHelper.processTouchEvent(event); return true;&#125; 处理computeScroll 因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法) 1234567@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mViewDragHelper != null &amp;&amp; mViewDragHelper.continueSettling(true))&#123; invalidate(); &#125;&#125; 处理CallBack回调 1234567891011121314151617181920212223242526private ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() &#123; // tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动 @Override public boolean tryCaptureView(View child, int pointerId) &#123; &#125; // clampViewPositionHorizontal() 判断水平方向上将要移动到的位置 // left 将要移动到的left值 // dx 表示速度 @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; &#125; // 同clampViewPositionHorizontal(), 换成了垂直方向而已 @Override public int clampViewPositionVertical(View child, int top, int dy) &#123; &#125; // 手指拖拽后释放 // releasedChild 拖拽的view // xvel, yvel拖拽动速度 @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; &#125;&#125;; ViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法 还有一些常用的关于边缘滑动相关的重写方法 在这里就不写了 例子实现一个支持拖拽, 有粘性的ViewGroup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class DragLayout extends LinearLayout &#123; private float mRaftValue = UIUtils.dip2Px(getContext(), 20); //回弹临界距离 private float mRaftYVel = 1000.0f; // 回弹临界速度 private ViewDragHelper mDragHelper; private OnDismissListener mOnDismissListener; private boolean mDragToggle = true; public DragLayout(@NonNull Context context) &#123; this(context, null); &#125; public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; public void setOnDismissListener(OnDismissListener onDismissListener) &#123; mOnDismissListener = onDismissListener; &#125; private void init() &#123; ViewDragHelper.Callback callback = new ViewDragHelper.Callback() &#123; private int mCurrentTop; @Override public boolean tryCaptureView(@NonNull View child, int pointerId) &#123; return mDragToggle; &#125; @Override public int clampViewPositionVertical(@NonNull View child, int top, int dy) &#123; // 禁止向上滑动 if (top &lt; 0) &#123; top = 0; &#125; mCurrentTop = top; return top; &#125; @Override public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); // 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画 // 还需要限定一个速度，优化用户体验 if (mCurrentTop &lt;= mRaftValue &amp;&amp; yvel &lt;= mRaftYVel) &#123; mDragHelper.settleCapturedViewAt(0, 0); invalidate(); &#125; else &#123; // 从底部滑出 if (mOnDismissListener != null) &#123; mOnDismissListener.onDismiss(); &#125; &#125; &#125; // 响应垂直滑动事件 // 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件 // 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中, // 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截. // 所以需要重写并返回一个非0值 @Override public int getViewVerticalDragRange(@NonNull View child) &#123; return 1; &#125; &#125;; mDragHelper = ViewDragHelper.create(this, callback); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; try &#123; mDragHelper.processTouchEvent(event); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true; &#125; @Override public void computeScroll() &#123; if (mDragHelper != null &amp;&amp; mDragHelper.continueSettling(true)) &#123; invalidate(); &#125; &#125; public interface OnDismissListener &#123; void onDismiss(); &#125;&#125; 注意 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"外部View随着RecyclerView的滚动而显示或隐藏","slug":"Android/外部View随着RecyclerView的滚动而显示或隐藏","date":"2020-01-09T15:01:39.000Z","updated":"2020-01-09T15:16:41.826Z","comments":true,"path":"2020/01/09/Android/外部View随着RecyclerView的滚动而显示或隐藏/","link":"","permalink":"http://yoursite.com/2020/01/09/Android/外部View随着RecyclerView的滚动而显示或隐藏/","excerpt":"外部的View上滑显示, 下滑隐藏1234567891011121314151617181920212223242526272829mOutsideOnScrollListener = new OnScrollListener() &#123; boolean controlsVisible = false; int scrolledDistance = 0; @Override public void onScrollStateChanged(int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; scrolledDistance = 0; &#125; &#125; @Override public void onScrolled(int dx, int dy) &#123; if ((controlsVisible &amp;&amp; dy &lt; 0) || (!controlsVisible &amp;&amp; dy &gt; 0)&#123; scrolledDistance += dy; &#125; if (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123; //UP scrolledDistance = 0; controlsVisible = false; view.onShow(); &#125; else if (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123; //DOWN scrolledDistance = 0; controlsVisible = true; view.onPause(); &#125; &#125;&#125;;","text":"外部的View上滑显示, 下滑隐藏1234567891011121314151617181920212223242526272829mOutsideOnScrollListener = new OnScrollListener() &#123; boolean controlsVisible = false; int scrolledDistance = 0; @Override public void onScrollStateChanged(int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; scrolledDistance = 0; &#125; &#125; @Override public void onScrolled(int dx, int dy) &#123; if ((controlsVisible &amp;&amp; dy &lt; 0) || (!controlsVisible &amp;&amp; dy &gt; 0)&#123; scrolledDistance += dy; &#125; if (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123; //UP scrolledDistance = 0; controlsVisible = false; view.onShow(); &#125; else if (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123; //DOWN scrolledDistance = 0; controlsVisible = true; view.onPause(); &#125; &#125;&#125;; 我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。 123if ((controlsVisible &amp;&amp; dy &lt; 0) || (!controlsVisible &amp;&amp; dy &gt; 0)) &#123; scrolledDistance += dy;&#125; 如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。 1234567891011if (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123; //UP scrolledDistance = 0; controlsVisible = false; view.onResume();&#125; else if (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123; //DOWN scrolledDistance = 0; controlsVisible = true; view.onPause();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自动滚播TextView","slug":"Android/自动滚播TextView","date":"2019-12-31T06:49:08.000Z","updated":"2019-12-31T07:28:48.565Z","comments":true,"path":"2019/12/31/Android/自动滚播TextView/","link":"","permalink":"http://yoursite.com/2019/12/31/Android/自动滚播TextView/","excerpt":"","text":"要实现一个自动滚播的自定义View123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class AutoSwitchView extends AppCompatTextView &#123; private final int DEFAULT_IDLE_TIME = 3000; private final int DEFAULT_SWITCH_TIME = 1000; private int mIdleTime = DEFAULT_IDLE_TIME; private int mSwitchTime = DEFAULT_SWITCH_TIME; private Paint mPaint; private String mCurStr; private String mNextStr; private List&lt;String&gt; mContentList; private int mCurIndex = 0; private float mCurValue; private boolean mIsRunning = false; private ValueAnimator mAnimator; private Paint.FontMetrics mFontMetrics; private Runnable mRunnable; private int mWidth; private int mPaddingLeft; private int mPaddingRight; private int mPaddingTop; private int mPaddingBottom; private int mHeight; private float mTextBaseY; public AutoSwitchView(Context context) &#123; super(context); init(context); &#125; public AutoSwitchView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public AutoSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; mPaint = new Paint(); mPaint.setTextAlign(Paint.Align.CENTER); mAnimator = ValueAnimator.ofFloat(0, 1); mAnimator.setStartDelay(mIdleTime); mAnimator.setDuration(mSwitchTime); mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurValue = (float) animation.getAnimatedValue(); // 必须要加这个判断, 不然会出现问题 if (mCurValue &lt; 1.0) &#123; invalidate(); &#125; &#125; &#125;); mAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation, boolean isReverse) &#123; if (!mIsRunning) &#123; return; &#125; mCurIndex = (mCurIndex + 1) % mContentList.size(); mCurStr = mContentList.get(mCurIndex); mNextStr = mContentList.get((mCurIndex + 1) % mContentList.size()); if (mRunnable == null) &#123; mRunnable = new Runnable() &#123; @Override public void run() &#123; mAnimator.start(); &#125; &#125;; &#125; postDelayed(mRunnable, mIdleTime); &#125; @Override public void onAnimationCancel(Animator animation) &#123; mIsRunning = false; &#125; &#125;); &#125; public void start() &#123; if (mContentList == null || mContentList.size() == 0) return; if (mIsRunning) &#123; return; &#125; if (mContentList.size() &gt; 1) &#123; mCurStr = mContentList.get(0); mNextStr = mContentList.get(1); &#125; else &#123; mCurStr = mContentList.get(0); mNextStr = mContentList.get(0); &#125; mCurIndex = 0; mIsRunning = true; mAnimator.start(); mAnimator.setStartDelay(mIdleTime); &#125; public void stop() &#123; if (mRunnable != null) &#123; removeCallbacks(mRunnable); &#125; mAnimator.cancel(); mIsRunning = false; mCurIndex = 0; &#125; public void setContentList(List&lt;String&gt; contentList) &#123; if (contentList == null || contentList.size() == 0) return; mContentList = contentList; start(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mWidth = MeasureSpec.getSize(widthMeasureSpec); mPaddingLeft = getPaddingLeft(); mPaddingRight = getPaddingRight(); mPaddingTop = getPaddingTop(); mPaddingBottom = getPaddingBottom(); mPaint.setTextSize(getTextSize()); mFontMetrics = mPaint.getFontMetrics(); mTextBaseY = -mFontMetrics.top + mPaddingTop; mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom; setMeasuredDimension(mWidth, mHeight); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / 2; float nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / 2; float baseY = 2 * mTextBaseY * (0.5f - mCurValue); if (baseY &gt; 0) &#123; canvas.drawText(mCurStr, curStartX, baseY, mPaint); &#125; else &#123; canvas.drawText(mNextStr, nextStartX, 2 * mTextBaseY + baseY, mPaint); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"ViewModel,LiveData和Lifecycle","slug":"Android/ViewModel-LiveData和LifeCricle","date":"2019-12-21T12:19:41.000Z","updated":"2019-12-21T15:15:01.295Z","comments":true,"path":"2019/12/21/Android/ViewModel-LiveData和LifeCricle/","link":"","permalink":"http://yoursite.com/2019/12/21/Android/ViewModel-LiveData和LifeCricle/","excerpt":"ViewModelViewModel通常在Activity、Fragment 的生命周期内被创建并且与之关联在一起直到Activity 被 finish 掉。(也就是说使用ViewModel并不会像MVP模式的Presenter一样会内存泄漏的风险)当 Activity、Fragment 被重新创建的时候，通过 ViewModelProvides 可以重新获得与之关联的 ViewModel，从而确保数据不会丢失。","text":"ViewModelViewModel通常在Activity、Fragment 的生命周期内被创建并且与之关联在一起直到Activity 被 finish 掉。(也就是说使用ViewModel并不会像MVP模式的Presenter一样会内存泄漏的风险)当 Activity、Fragment 被重新创建的时候，通过 ViewModelProvides 可以重新获得与之关联的 ViewModel，从而确保数据不会丢失。 从Activity和Fragment中获取ViewModel实例:12// 有可能是创建ViewModel有可能是重新连接已有的ViewModelXxxxViewModel XxxxViewModel = ViewModelProviders.of(this).get(XxxxViewModel.class); ViewModelProviders: (不同于ViewModelProvider)12345678910@NonNull@MainThreadpublic static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(activity), factory);&#125; ViewModelStores: (不同于ViewModelStore)ViewModelStores.of:12345678910@NonNull@MainThreadpublic static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; // ViewModelStoreOwner是一个接口，只有一个方法，在 27.1.0 的 Fragment和Activity 已经实现了该接口 return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; // 兼容27.1.0以下版本的 support 库. return holderFragmentFor(activity).getViewModelStore(); &#125; 1234567891011121314151617181920// 27.1.0 以下的版本 google 则通过创建一个不可见的实现 ViewModelStoreOwner接口的 fragment 去做兼容HolderFragment holderFragmentFor(FragmentActivity activity) &#123; FragmentManager fm = activity.getSupportFragmentManager(); HolderFragment holder = findHolderFragment(fm); if (holder != null) &#123; return holder; &#125; holder = mNotCommittedActivityHolders.get(activity); if (holder != null) &#123; return holder; &#125; if (!mActivityCallbacksIsAdded) &#123; mActivityCallbacksIsAdded = true; activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks); //注册生命周期，activity 销毁时将 HolderFragment 从 mNotCommittedActivityHolders 移除 &#125; holder = createHolderFragment(fm); mNotCommittedActivityHolders.put(activity, holder); return holder;&#125; ViewModelProviderViewModelProvider.get:1234567891011121314151617181920@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); // 可以看出ViewModelStore是存储ViewModel的地方 if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; ViewModel的销毁FragmentActivity:(API27+, 实现了ViewModelStoreOwner接口)12345678910protected void onDestroy() &#123; super.onDestroy(); // isChangingConfigurations()判断应用是否处于参数改变的情况, 比如横竖屏切换 // 所以横竖屏切换并不会清楚掉ViewModelStore中的ViewModel if (this.mViewModelStore != null &amp;&amp; !this.isChangingConfigurations()) &#123; this.mViewModelStore.clear(); &#125; this.mFragments.dispatchDestroy();&#125; HolderFragment: (API27以下, 通过添加HolderFragment)12345678910@Overridepublic void onDestroy() &#123; super.onDestroy(); mViewModelStore.clear();&#125;``` ### 在Fragment间共享数据(共享ViewModel)```javaViewModel viewModel = ViewModelProviders.of(getActivity()).get(UserViewModel::class.java) 总结: ViewModel的存储 ViewModel存储在ViewModelStore中. Activity和Fragment会持有ViewModelStore实例, 存储ViewModel集合(MVVM中一个View中可能对应多个ViewModel) 在Ativity和Framgent销毁重建时, 会通过某种方式保存ViewModelStore(还不清楚时怎么保存的…) ViewModelProviders, 从Fragment和Activity中获取ViewModelStore对象, 并new实例化出一个ViewModelProvider对象 LifecycleLifecycle的STATE和Activity生命周期的对应关系12345678public enum State&#123; DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED;&#125; DESTROYED，在组件的onDestroy调用前，会变成该状态，变成此状态后将不会再出现任何状态改变，也不会发送任何生命周期事件 INITIALIZED，构造函数执行完成后但onCreate未执行时为此状态，是最开始时的状态 CREATED，在onCreate调用之后，以及onStop调用前会变成此状态 STARTED，在onStart调用之后，以及onPause调用前会变成此状态 RESUMED，再onResume调用之后会变成此状态 LifecycleOwner接口LifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口。 只要继承这些类型，可以轻松的通过LifecycleOwner#getLifecycle()获取到Lifecycle实例.这是一种解耦实现,LifecycleOwner不包含任何有关生命周期管理的逻辑,实际的逻辑都在Lifecycle实例中,我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏. 需要注意的是并不是所有的google官方的Actiivyt和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有v4包下的Fragment, FragmentActivity和AppCompatActivity SupportActivity类中对Lifecycle的使用12// 这个类继承自Lifecycle类private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); 12345// SupportActiity类中只有onSaveInstanceState调用了Lifecycle的相关方法protected void onSaveInstanceState(Bundle outState) &#123; this.mLifecycleRegistry.markState(State.CREATED); super.onSaveInstanceState(outState);&#125; 我们在查看源码时发现 Lifecycle 只在 Activity 的 onSaveInstanceState 中 调用了 mLifecycleRegistry.markState(Lifecycle.State.CREATED) 方法，在其他生命周期中并没有 Lifecycle 的相关代码，那 support 库中是怎么做到 disptch event 的呢？ ReportFragment在SupportActivity的onCreate方法中有一行代码, 它创建了一个不可见的 fragment 去分发 event1234protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this);&#125; 123456789101112131415161718192021@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE);&#125;private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; LiveData提供一个Observer接口给客户端，客户端实现这个接口，并将引用传递给它，当我们调用 LiveData 的 setValue 或 postValue 的时候，LiveData 就会去回调这个接口的方法，其实也就是LiveData 自己实现了观察者模式。不过 LiveData 搞定了一个让我们长期以来头疼的事情，那就是当 Activity、Fragment 不可见的时候 UI 不要更新的问题，其内部其实也是监听了 LifecycleOwner 的可见和不可见的方法，当 Activity、Fragment 不可见的时候就不回调 Observer 的方法，当 Activity、Fragment 变成可见的时候，就对比最新的值和最后发出去的值是否是同一个，不同的话就发送最新的值，确保 Activity、Fragment 可见的时候用户看到的一定是最新的数据。 observe12345678910111213141516171819@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; // 讲LifecycleOwner和Observer组装起来 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); &#125; if (existing != null) &#123; return; &#125; // 讲Observer加入lifecycle的监听之中 owner.getLifecycle().addObserver(wrapper);&#125; 123456789101112131415161718192021222324252627282930313233class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; // 当Lifecycle的state的改变时会回调这个方法 @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; mOwner.getLifecycle().removeObserver(this); &#125;&#125; 1234567891011121314151617181920void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; // 当Lifecycle的状态由不可见变为可见, 重新分发value if (mActive) &#123; dispatchingValue(this); &#125;&#125; postValue1234567891011121314151617181920212223242526272829303132protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125;&#125;;@MainThreadprotected void setValue(T value) &#123; assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null);&#125; postValue方法和setValue最终都会保证是在主线程执行的. 所以LiveData自动实现了线程的跳转.","categories":[],"tags":[],"keywords":[]},{"title":"Glide源码-缓存机制","slug":"Android/源码解析/Glide源码-缓存机制","date":"2019-11-18T08:52:17.000Z","updated":"2019-12-21T12:16:41.877Z","comments":true,"path":"2019/11/18/Android/源码解析/Glide源码-缓存机制/","link":"","permalink":"http://yoursite.com/2019/11/18/Android/源码解析/Glide源码-缓存机制/","excerpt":"Glide的配置在实例化Glide的时候, 对很多重要的部分做了初始化.","text":"Glide的配置在实例化Glide的时候, 对很多重要的部分做了初始化. 1234567// 起始入口public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125;... // 省略中间步骤 一直向下追溯, 可以找到Glide类的这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041Glide createGlide() &#123; if (sourceService == null) &#123; // 初始化加载网络图片的线程池 final int cores = Math.max(1, Runtime.getRuntime().availableProcessors()); sourceService = new FifoPriorityThreadPoolExecutor(cores); &#125; if (diskCacheService == null) &#123; // 初始化加载磁盘缓存的线程池 diskCacheService = new FifoPriorityThreadPoolExecutor(1); &#125; // 初始化内存缓存池, 可以看到, 是一个lrucache MemorySizeCalculator calculator = new MemorySizeCalculator(context); if (bitmapPool == null) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; int size = calculator.getBitmapPoolSize(); bitmapPool = new LruBitmapPool(size); &#125; else &#123; bitmapPool = new BitmapPoolAdapter(); &#125; &#125; if (memoryCache == null) &#123; memoryCache = new LruResourceCache(calculator.getMemoryCacheSize()); &#125; if (diskCacheFactory == null) &#123; diskCacheFactory = new InternalCacheDiskCacheFactory(context); &#125; if (engine == null) &#123; // 实例化Glide Engine engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService); &#125; if (decodeFormat == null) &#123; decodeFormat = DecodeFormat.DEFAULT; &#125; return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);&#125; 内存缓存Engine-load1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private final Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;...public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = LogTime.getLogTime(); // 组装key final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); // 先从内存cache中获取 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from cache\", startTime, key); &#125; return null; &#125; // 从ActiveResources获取 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key); &#125; return null; &#125; // 后面的内容暂时和内存缓存无关 EngineJob current = jobs.get(key); if (current != null) &#123; // 当已经存在相同的图片加载job, 直接添加新的callback即可 current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Added to existing load\", startTime, key); &#125; return new LoadStatus(cb, current); &#125; EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); // 具体的图片请求工作在这个runnable中 EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(runnable); return new LoadStatus(cb, engineJob);&#125; 可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取.ActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合: 为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。 存储的正在使用的图片资源的弱引用: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用 来看看对lrucache和ActiveResources的操作 内存cache的获取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 从cache中获取private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; // 检查内存缓存是否被禁用 if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; // cache命中, 从lrucache中取出后放入ActiveResources cached.acquire(); activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue())); &#125; return cached;&#125;// 从cache中获取资源private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; // 注意这里是直接remove的 Resource&lt;?&gt; cached = cache.remove(key); final EngineResource result; if (cached == null) &#123; result = null; &#125; else if (cached instanceof EngineResource) &#123; // Save an object allocation if we've cached an EngineResource (the typical case). result = (EngineResource) cached; &#125; else &#123; result = new EngineResource(cached, true /*isCacheable*/); &#125; return result;&#125;private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123; // 检查内存cache是否被禁用 if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; active = null; WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key); if (activeRef != null) &#123; active = activeRef.get(); if (active != null) &#123; // ActiveResource命中 active.acquire(); &#125; else &#123; // 弱引用的对象被释放了, 直接remove activeResources.remove(key); &#125; &#125; return active;&#125; 内存cache的释放先来看看resource中如何表示图片需要被释放1234567891011121314151617class EngineResource&lt;Z&gt; implements Resource&lt;Z&gt; &#123; private int acquired; ... void acquire() &#123; ... // 省略异常处理 ++acquired; &#125; void release() &#123; ... // 省略异常处理 if (--acquired == 0) &#123; // 当acquired为0的使用, 表示当前图片没有被引用 listener.onResourceReleased(key, this); &#125; &#125;&#125; resource中listener的回调是在EngineJob类中实现的 1234567891011// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache@Overridepublic void onResourceReleased(Key cacheKey, EngineResource resource) &#123; Util.assertMainThread(); activeResources.remove(cacheKey); if (resource.isCacheable()) &#123; cache.put(cacheKey, resource); &#125; else &#123; resourceRecycler.recycle(resource); &#125;&#125; 磁盘缓存首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理. 入口内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中 123456789101112131415161718192021222324private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; return decodeFromCache(); &#125; else &#123; return decodeFromSource(); &#125;&#125;// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片private Resource&lt;?&gt; decodeFromCache() throws Exception &#123; Resource&lt;?&gt; result = null; try &#123; result = decodeJob.decodeResultFromCache(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"Exception decoding result from cache: \" + e); &#125; &#125; if (result == null) &#123; result = decodeJob.decodeSourceFromCache(); &#125; return result; &#125; 磁盘cache读取1234567891011121314151617181920212223242526272829303132333435public Resource&lt;Z&gt; decodeResultFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheResult()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; transformed = loadFromCache(resultKey); startTime = LogTime.getLogTime(); Resource&lt;Z&gt; result = transcode(transformed); return result;&#125;public Resource&lt;Z&gt; decodeSourceFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheSource()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey()); return transformEncodeAndTranscode(decoded);&#125;private Resource&lt;T&gt; loadFromCache(Key key) throws IOException &#123; File cacheFile = diskCacheProvider.getDiskCache().get(key); if (cacheFile == null) &#123; return null; &#125; Resource&lt;T&gt; result = null; try &#123; result = loadProvider.getCacheDecoder().decode(cacheFile, width, height); &#125; finally &#123; if (result == null) &#123; diskCacheProvider.getDiskCache().delete(key); &#125; &#125; return result;&#125; 磁盘缓存读取这里挺好懂的 磁盘cache写入缓存原始图片直接贴调用过程吧 EngineRunnable.decodeFromSource()-&gt; EngineRunnable.decodeFromSource()-&gt; DecodeJob.decodeFromSource()-&gt; DecodeJob.decodeSource()-&gt; DecodeJob.decodeFromSourceData()-&gt; DecodeJob.cacheAndDecodeSourceData 1234567891011121314151617181920212223242526private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); // 从网络获取图片 final A data = fetcher.loadData(priority); if (isCancelled) &#123; return null; &#125; decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded;&#125;private Resource&lt;T&gt; cacheAndDecodeSourceData(A data) throws IOException &#123; long startTime = LogTime.getLogTime(); SourceWriter&lt;A&gt; writer = new SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data); diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer); startTime = LogTime.getLogTime(); // ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个? Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey()); return result;&#125; 缓存处理过后的图片EngineRunnable.decodeFromSource()-&gt; EngineRunnable.decodeFromSource()-&gt; DecodeJob.decodeFromSource()-&gt; DecodeJob.transformEncodeAndTranscode-&gt; DecodeJob.writeTransformedToCache 12345678910111213141516171819202122private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); // 先转换图片 Resource&lt;T&gt; transformed = transform(decoded); // 写入磁盘 writeTransformedToCache(transformed); startTime = LogTime.getLogTime(); // 转码 Resource&lt;Z&gt; result = transcode(transformed); return result;&#125;private void writeTransformedToCache(Resource&lt;T&gt; transformed) &#123; if (transformed == null || !diskCacheStrategy.cacheResult()) &#123; return; &#125; long startTime = LogTime.getLogTime(); SourceWriter&lt;Resource&lt;T&gt;&gt; writer = new SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed); diskCacheProvider.getDiskCache().put(resultKey, writer);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"glide","slug":"glide","permalink":"http://yoursite.com/tags/glide/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Glide源码-主要流程","slug":"Android/源码解析/Glide源码-主要流程","date":"2019-11-17T18:00:05.000Z","updated":"2019-12-21T12:16:41.877Z","comments":true,"path":"2019/11/18/Android/源码解析/Glide源码-主要流程/","link":"","permalink":"http://yoursite.com/2019/11/18/Android/源码解析/Glide源码-主要流程/","excerpt":"API调用123Glide.with(fragment) .load(myUrl) .into(imageView);","text":"API调用123Glide.with(fragment) .load(myUrl) .into(imageView); with过程主要工作将图片加载和对应的生命周期绑定(如activity, fragment等)绑定生命周期的优点: 在activity, fragment等销毁的时候, 停止对应的图片加载. 避免消耗资源 防止空指针问题的出现 Glide123456789101112131415161718192021222324public static RequestManager with(Context context) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(context);&#125;public static RequestManager with(Activity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125;public static RequestManager with(FragmentActivity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125;public static RequestManager with(android.app.Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment);&#125;public static RequestManager with(Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment);&#125; RequestManagerRetriever前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public RequestManager get(Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException(\"You cannot start a load on a null Context\"); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context);&#125;// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定private RequestManager getApplicationManager(Context context) &#123; // Either an application context or we're on a background thread. if (applicationManager == null) &#123; synchronized (this) &#123; if (applicationManager == null) &#123; // Normally pause/resume is taken care of by the fragment we add to the fragment or activity. // However, in this case since the manager attached to the application will not receive lifecycle // events, we must force the manager to start resumed using ApplicationLifecycle. // 双校验锁 懒汉单例 // 将资源加载与整个APP的生命周期绑定 applicationManager = new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(), new EmptyRequestManagerTreeNode()); &#125; &#125; &#125; return applicationManager;&#125;// 获取RequestManagerpublic RequestManager get(Activity activity) &#123; if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet(activity, fm); &#125;&#125;.... // 省略其他的重载方法// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125;// 创建并添加RequestManagerFragmentRequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; // pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的 current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; // 使用FragmentManager添加fragment current = new RequestManagerFragment(); pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current;&#125; load过程RequestManager-load123public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125; GenericRequestBuilderRequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法.跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了 123456// ModelType是一个泛型通配符, model是加载的参数public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123; this.model = model; isModelSet = true; return this;&#125; into过程GenericRequestBuilder-into123456789101112131415161718192021222324252627282930313233public Target&lt;TranscodeType&gt; into(ImageView view) &#123; Util.assertMainThread(); if (view == null) &#123; throw new IllegalArgumentException(\"You must pass in a non null View\"); &#125; // ...省略代码 return into(glide.buildImageViewTarget(view, transcodeClass));&#125;public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; Util.assertMainThread(); ... // 省略代码 Request previous = target.getRequest(); // 清楚target上旧的图片请求 if (previous != null) &#123; previous.clear(); requestTracker.removeRequest(previous); previous.recycle(); &#125; Request request = buildRequest(target); target.setRequest(request); lifecycle.addListener(target); // 开始请求图片 requestTracker.runRequest(request); return target;&#125; 为什么要清楚target上旧的图片请求: 由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。 在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象 GenericRequestBuilder-runRequest12345678910public void runRequest(Request request) &#123; requests.add(request); if (!isPaused) &#123; // 请求加载没有暂停, 则开始请求 request.begin(); &#125; else &#123; // 请求加载暂停了, 则放入到等待队列中去 pendingRequests.add(request); &#125;&#125; 1234567891011121314151617181920212223242526@Overridepublic void begin() &#123; startTime = LogTime.getLogTime(); if (model == null) &#123; onException(null); return; &#125; status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; // 如果用户在调用API时配置了图片的大小, 直接下一步 // onSizeReady这个方法很重要 onSizeReady(overrideWidth, overrideHeight); &#125; else &#123; // 如果没有, 则获取ImageView的大小 // 这个方法最终也会走到onSizeReady方法 target.getSize(this); &#125; if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123; target.onLoadStarted(getPlaceholderDrawable()); &#125; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime)); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@Overridepublic void onSizeReady(int width, int height) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime)); &#125; if (status != Status.WAITING_FOR_SIZE) &#123; return; &#125; status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); if (dataFetcher == null) &#123; onException(new Exception(\"Failed to load model: \\'\" + model + \"\\'\")); return; &#125; ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime)); &#125; loadedFromMemoryCache = true; // 前面的代码都不知道在讲啥, 反正这个engine.load是重点 loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime)); &#125;&#125; Engine-load获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = LogTime.getLogTime(); final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from cache\", startTime, key); &#125; return null; &#125; EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key); &#125; return null; &#125; EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Added to existing load\", startTime, key); &#125; return new LoadStatus(cb, current); &#125; // 前面的缓存策略, 只有再说 EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(runnable); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Started new load\", startTime, key); &#125; return new LoadStatus(cb, engineJob);&#125; EngineRunnable获取网络图片, 并编解码 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void run() &#123; if (isCancelled) &#123; return; &#125; Exception exception = null; Resource&lt;?&gt; resource = null; try &#123; // decode()方法是重点 // decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等 // 这里就不分析了, 太麻烦 resource = decode(); &#125; catch (OutOfMemoryError e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, \"Out Of Memory Error decoding\", e); &#125; exception = new ErrorWrappingGlideException(e); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, \"Exception decoding\", e); &#125; exception = e; &#125; if (isCancelled) &#123; if (resource != null) &#123; resource.recycle(); &#125; return; &#125; if (resource == null) &#123; onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125;&#125;private void onLoadComplete(Resource resource) &#123; // manager是一个EngineJob对象 manager.onResourceReady(resource);&#125; EngineJob12345678910111213141516171819202122232425262728293031@Overridepublic void onResourceReady(final Resource&lt;?&gt; resource) &#123; this.resource = resource; // 这个handler最终会执行到handleResultOnMainThread方法 MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();&#125;private void handleResultOnMainThread() &#123; if (isCancelled) &#123; resource.recycle(); return; &#125; else if (cbs.isEmpty()) &#123; throw new IllegalStateException(\"Received a resource without any callbacks to notify\"); &#125; engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it // synchronously released by one of the callbacks. engineResource.acquire(); listener.onEngineJobComplete(key, engineResource); for (ResourceCallback cb : cbs) &#123; if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); cb.onResourceReady(engineResource); &#125; &#125; // Our request is complete, so we can release the resource. engineResource.release();&#125; 就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"glide","slug":"glide","permalink":"http://yoursite.com/tags/glide/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-CallServerInterceptor","slug":"Android/源码解析/OkHttp3源码-CallServerInterceptor","date":"2019-11-16T17:10:03.000Z","updated":"2019-12-21T12:16:41.877Z","comments":true,"path":"2019/11/17/Android/源码解析/OkHttp3源码-CallServerInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/17/Android/源码解析/OkHttp3源码-CallServerInterceptor/","excerpt":"CallServerInterceptor主要负责具体的访问服务端","text":"CallServerInterceptor主要负责具体的访问服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** This is the last interceptor in the chain. It makes a network call to the server. */ @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); // HttpCodec相当于流, 将请求header写入流 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100 // Continue\" response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. // 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流. // \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体 if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) &#123; // 发送请求头 httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); // 读取response responseBuilder = httpCodec.readResponseHeaders(true); &#125; // 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, // 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体 if (responseBuilder == null) &#123; // Write the request body if the \"Expect: 100-continue\" expectation was met. // 将请求体写入流 realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. // 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接) streamAllocation.noNewStreams(); &#125; &#125; // 结束发送请求 httpCodec.finishRequest(); if (responseBuilder == null) &#123; realChain.eventListener().responseHeadersStart(realChain.call()); // 读取response的头 responseBuilder = httpCodec.readResponseHeaders(false); &#125; // 构建带响应头的响应体 Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) &#123; // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); &#125; realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; // 构建响应体 response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-ConnectInterceptor","slug":"Android/源码解析/OkHttp3源码-ConnectInterceptor","date":"2019-11-15T15:45:15.000Z","updated":"2019-12-21T12:16:41.877Z","comments":true,"path":"2019/11/15/Android/源码解析/OkHttp3源码-ConnectInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/15/Android/源码解析/OkHttp3源码-ConnectInterceptor/","excerpt":"ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.","text":"ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用. 参考链接:https://www.jianshu.com/p/4bf4c796db6fhttps://juejin.im/post/5b73abe55188256142142d89——连接池复用) intercept123456789101112@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection);&#125; ConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单. StreamAllocation流, 连接, 请求HTTP通信执行网络”请求”需要在”连接”上建立一个新的”流”. StreamAllocation称之流的桥梁，它负责为一次”请求”寻找”连接”并建立”流”来看看StreamAllocation源代码上的官方注释:1234567891011121314/** * &lt;ul&gt; * &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are * potentially slow to establish so it is necessary to be able to cancel a connection * currently being connected. * &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on * connections. Each connection has its own allocation limit, which defines how many * concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream * at a time, HTTP/2 typically carry multiple. * &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and * its follow up requests. We prefer to keep all streams of a single call on the same * connection for better behavior and locality. * &lt;/ul&gt; */ 翻译: Connection: 到远端服务器的物理连接. Socket连接的具体工作者 Stream: 在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个. 在okhttp3的流是HttpCodec表示 Call: 对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中 newStream, findHealthyConnectionnewStream获取合适的连接, 从连接中获取流123456789101112131415161718192021public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123; int connectTimeout = client.connectTimeoutMillis(); int readTimeout = client.readTimeoutMillis(); int writeTimeout = client.writeTimeoutMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; //获取一个连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); //实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec HttpCodec resultCodec = resultConnection.newCodec(client, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125; findHealthyConnecton不断循环, 直到获取一个healthy?的连接健康的连接, 大概意思是socket能正常使用的意思吧 123456789101112131415161718192021222324252627282930/** * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated * until a healthy connection is found. */private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); // If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn't, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; // 如果这个连接不健康, // 禁用这条连接, 重复寻找可用的连接 noNewStreams(); continue; &#125; return candidate; &#125;&#125; findConnection-重点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 /** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */ /** * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接 */private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; ... // 省略代码 // Attempt to use an already-allocated connection. We need to be careful here because our // already-allocated connection may have been restricted from creating new streams. releasedConnection = this.connection; toClose = releaseIfNoNewStreams(); if (this.connection != null) &#123; //如果当前connection不为空可以直接使用 // We had an already-allocated connection and it's good. result = this.connection; releasedConnection = null; &#125; if (!reportedAcquired) &#123; // If the connection was never reported acquired, don't report it as released! releasedConnection = null; &#125; //当前这个connection不能使用，尝试从连接池里面获取一个请求 if (result == null) &#123; // Attempt to get a connection from the pool. // Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法 Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; foundPooledConnection = true; result = connection; &#125; else &#123; selectedRoute = route; &#125; &#125; &#125; closeQuietly(toClose); ... // 省略代码 if (result != null) &#123; // 找到一条可复用的连接 // If we found an already-allocated or pooled connection, we're done. return result; &#125; // 到达这里表示没有找到 // 切换路由再在连接池里面找下，如果有则返回 // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; // 检查是否有其他路由 if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; synchronized (connectionPool) &#123; if (canceled) throw new IOException(\"Canceled\"); if (newRouteSelection) &#123; // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. // 有其他路由, 遍历RooteSelector List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) &#123; Route route = routes.get(i); Internal.instance.get(connectionPool, address, this, route); if (connection != null) &#123; foundPooledConnection = true; result = connection; this.route = route; break; &#125; &#125; &#125; if (!foundPooledConnection) &#123; //没找到则创建一条 if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); //往连接中增加流 acquire(result, false); &#125; &#125; // If we found a pooled connection on the 2nd time around, we're done. //如果第二次找到了可以复用的，则返回 if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); return result; &#125; // Do TCP + TLS handshakes. This is a blocking operation. // 建立连接,开始握手 result.connect( connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener); // 将这条路由从错误缓存中清除 routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; reportedAcquired = true; // Pool the connection. //将这个请求加入连接池 Internal.instance.put(connectionPool, result); // If another multiplexed connection to the same address was created concurrently, then // release this connection and acquire that one. // 如果是多路复用，则合并 if (result.isMultiplexed()) &#123; // 返回的是一个重复的socket socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; // 关闭重复的socket closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; &#125; CollectionPool主要成员变量123456789101112131415161718192021222324252627282930313233343536373839404142/*** Background threads are used to cleanup expired connections. There will be at most a single* thread running per connection pool. The thread pool executor permits the pool itself to be* garbage collected.*//**被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). */private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp ConnectionPool\", true));/** The maximum number of idle connections for each address. */// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5private final int maxIdleConnections;// 允许的线程空闲的最大时间, 默认为5分钟private final long keepAliveDurationNs;// 清理的taskprivate final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) &#123; try &#123; ConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125;&#125;;// 连接池中的连接集合private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...final RouteDatabase routeDatabase = new RouteDatabase();// 标记清理线程是否在运行boolean cleanupRunning; ConnectionPool创建的位置:ConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs) cleanUpRunnable会被放入线程池的清理任务 1234567891011121314151617181920private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; // cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) &#123; try &#123; // 挂起清理线程 ConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125;&#125;; cleanUp找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** Performs maintenance on this pool, evicting the connection that has been idle the longest if* either it has exceeded the keep alive limit or the idle connections limit.** &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns* -1 if no further cleanups are required.*/long cleanup(long now) &#123; int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; // Find either a connection to evict, or the time that the next eviction is due. // 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection synchronized (this) &#123; for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123; RealConnection connection = i.next(); // If the connection is in use, keep searching. // pruneAndGetAllocationCount方法判断当前connection是否正在使用中 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++; continue; &#125; idleConnectionCount++; // If the connection is ready to be evicted, we're done. long idleDurationNs = now - connection.idleAtNanos; // 记录空闲最长的那个connection, 并且记录空闲的最长时间 if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; &#125; &#125; if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123; // We've found a connection to evict. Remove it from the list, then close it below (outside // of the synchronized block). // 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制 // 从connections集合中remove掉该connection connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123; // A connection will be ready to evict soon. // 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间 return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123; // All connections are in use. It'll be at least the keep alive duration 'til we run again. // 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理 return keepAliveDurationNs; &#125; else &#123; // No connections, idle or in use. // 根本没有connection, 返回-1, 直接终止清理任务 cleanupRunning = false; return -1; &#125; &#125; closeQuietly(longestIdleConnection.socket()); // Cleanup again immediately. return 0;&#125; pruneAndGetAllocationCount判断该连接是否是空闲的 1234567891011121314151617181920212223242526private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations; for (int i = 0; i &lt; references.size(); ) &#123; Reference&lt;StreamAllocation&gt; reference = references.get(i); //如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation if (reference.get() != null) &#123; i++; continue; &#125; ... // 省略代码 //如果没有引用，就移除 references.remove(i); connection.noNewStreams = true; //如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接 if (references.isEmpty()) &#123; connection.idleAtNanos = now - keepAliveDurationNs; return 0; &#125; &#125; //遍历结束后，返回引用的数量，说明当前连接是活跃连接 return references.size();&#125; 判断连接是否空闲过程:RealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用…), 若集合为空, 则该连接时空闲的. get和putget:123456789101112RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; //判断这个连接是否符合address和route, 判断过程很麻烦 if (connection.isEligible(address, route)) &#123; // 将streamAllocation和这个connection绑定 streamAllocation.acquire(connection, true); return connection; &#125; &#125; return null;&#125; put:1234567891011void put(RealConnection connection) &#123; assert (Thread.holdsLock(this)); if (!cleanupRunning) &#123; // 当清理任务没有工作的时候, 将任务放入线程池中运行 // 因为当connections集合为空时, 清理任务会终止 // ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ??? cleanupRunning = true; executor.execute(cleanupRunnable); &#125; connections.add(connection);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-CacheInterceptor","slug":"Android/源码解析/OkHttp3源码-CacheInterceptor","date":"2019-11-14T12:17:52.000Z","updated":"2019-12-21T12:16:41.877Z","comments":true,"path":"2019/11/14/Android/源码解析/OkHttp3源码-CacheInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/14/Android/源码解析/OkHttp3源码-CacheInterceptor/","excerpt":"OkHttp3源码-CacheInterceptor","text":"OkHttp3源码-CacheInterceptorokhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧.. 伪代码12345678910111213141516171819202122232425262728293031323334353637383940414243@Override public Response intercept(Chain chain) throws IOException &#123; // 1. 从Interceptor类的成员变量cache中尝试获取cache // 这里的cache是OkHttpClient在build用户手动添加的, 默认为null Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; // 从请求策略中获取缓存的 网络请求 和 response CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response(504); &#125; //3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache if (networkRequest == null) &#123; return cacheResponse; &#125; //4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络 networkResponse = chain.proceed(networkRequest); //5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response // (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用) if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() return response; &#125; &#125; //6 决定使用网络获取的response Response response = networkResponse; //7 将response装入cache中, 这里是用户添加的那个cache cache.put(response); return response;&#125; interceptor的详细过程看过伪代码, 现在来看详细过程, 就好多了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Override public Response intercept(Chain chain) throws IOException &#123; //默认cache为null,可以配置cache,不为空尝试获取缓存中的response Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //根据response,time,request创建一个缓存策略，用于判断怎样使用缓存 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. //如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. //不使用网络，但是有缓存，直接返回缓存 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //直接走后续拦截器 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. // 当缓存响应和网络响应同时存在的时候，选择用哪个 if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; // 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求 // (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档). // 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应 Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //使用网络响应 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //所以默认创建的OkHttpClient是没有缓存的 if (cache != null) &#123; // 缓存response if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. // 缓存Resposne的Header信息 CacheRequest cacheRequest = cache.put(response); // 缓存body return cacheWritingResponse(cacheRequest, response); &#125; // 只能okhttp3只能缓存GET请求....不然从cache中移除request // 很奇怪, 为什么要在这里加一个判断 if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; CacheOkHttpClient创建时添加cache:12345OkHttpClient.Builder builder = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .writeTimeout(20, TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .cache(new Cache(context.getExternalCacheDir(), 10*1024*1024)); InternalCache和Cache: InternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量 实现原理: 封装了对DiskLruCach的操作 注意点:Cache类只能缓存get请求. 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低. CacheStrategy构造方法1CacheStrategy(Request networkRequest, Response cacheResponse) 生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。 CacheStrategy.Factory1public Factory(long nowMillis, Request request, Response cacheResponse) 这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy request参数中附带有用户对缓存策略的配置: ( .cacheControl) 类如:1234Request request = new Request.Builder() .cacheControl(new CacheControl.Builder().noCache().build()) .url(\"http://publicobject.com/helloworld.txt\") .build();","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","slug":"Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","date":"2019-11-14T08:54:17.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/11/14/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/14/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor/","excerpt":"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor","text":"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptorRetryAndInterceptor主要功能:失败重连, 重定向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; // priorResponse表示在重定向时, 上一次request的response Response priorResponse = null; // while死循环, 在请求失败或者重定向之后重新发起请求 while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(\"Canceled\"); &#125; Response response; boolean releaseConnection = true; try &#123; // 进入责任链的下一个结点 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. // recover方法判断这个request是否可以失败重连 // 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getFirstConnectException(); &#125; releaseConnection = false; // 进入下一个while迭代, 开始失败重连 continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. // 如果priorResponse不为null, 将其加入到当前response中 if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; // followUp意思是重定向 Request followUp; try &#123; // followUpRequest方法: 重定向时根据response构建新的request followUp = followUpRequest(response, streamAllocation.route()); &#125; catch (IOException e) &#123; streamAllocation.release(); throw e; &#125; // followUp为空, 表示没有重定向了, 当前response为最终结果, return if (followUp == null) &#123; streamAllocation.release(); return response; &#125; // 有重定向, 关闭响应流 closeQuietly(response.body()); // 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; // 判断是否是不可重定向的类型 if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code()); &#125; if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; // 更新request 和 priorResponse request = followUp; priorResponse = response; &#125;&#125; RetryAndInterceptor伪代码1234567891011121314151617181920212223242526272829303132333435@Override public Response intercept(Chain chain) throws IOException &#123; Response response; Request request = chain.request; StreamAllocation streamAllocation = new StreamAllocation(); int followUpCount = 0; while(true)&#123; try&#123; response = realChain.proceed(request, streamAllocation, null, null); &#125;catch(OkhttpException e)&#123; if (!recover()) throw e; continue; &#125;catch(OtherException e)&#123; throw e; &#125; Request followUp; try &#123; followUp = followUpRequest(response, streamAllocation.route()); &#125; catch (IOException e) &#123; throw e; &#125; if(followUp == null) return response; if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw new Exception(\"Too many follow-up requests: \" + followUpCount); &#125; request = followUp; &#125;&#125; BridgeInterceptor这个拦截器比较简单, 提一下源代码上的注释吧 12345678910/*** Bridges from application code to network code. First it builds a network request from a user* request. Then it proceeds to call the network. Finally it builds a user response from the network* response.*//*** 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。*/","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-责任链的分析","slug":"Android/源码解析/OkHttp3源码-责任链的分析","date":"2019-11-14T07:52:46.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/11/14/Android/源码解析/OkHttp3源码-责任链的分析/","link":"","permalink":"http://yoursite.com/2019/11/14/Android/源码解析/OkHttp3源码-责任链的分析/","excerpt":"okhttp3源码-责任链的分析okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程","text":"okhttp3源码-责任链的分析okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程 getResponseWithInterceptorChain()12345678910111213141516171819202122232425Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); Response response = chain.proceed(originalRequest); if (retryAndFollowUpInterceptor.isCanceled()) &#123; closeQuietly(response); throw new IOException(\"Canceled\"); &#125; return response; &#125;&#125; 每个拦截器的简单说明: 用户拦截器：通过Builder的addInterceptor方法添加的拦截器。 RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。 BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。 CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程 ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。 CallServerInterceptor：和服务器通信，完成Http请求。所以我们可以总结出网络请求的调用流程： Chain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类 RealInterceptorChian12345678910111213141516171819202122232425262728293031323334353637@Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection);&#125;public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; ... // 省略一些异常处理的代码 // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptor + \" must call proceed() exactly once\"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( \"interceptor \" + interceptor + \" returned a response with no body\"); &#125; return response;&#125; interceptor.intercept(chain)伪代码123456789101112131415161718@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); ... // 处理request Response response; try &#123; // 继续责任链的下一个结点 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (Exception e) &#123; ... // &#125; ... // 处理response&#125; 梳理一下这个责任链模式的流程: (‘ -&gt; ‘表示调用关系)-&gt; getResponseWithInterceptorChain()-&gt; chain.process(request)-&gt; interceptor.intercept(nextChain)-&gt; chain.process(request)-&gt; interceptor.intercept(nextChain)-&gt; … // 循环直至责任链最后一个结点","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"},{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-发起请求的主要流程","slug":"Android/源码解析/OkHttp3源码-发起请求的主要流程","date":"2019-11-13T13:21:04.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/11/13/Android/源码解析/OkHttp3源码-发起请求的主要流程/","link":"","permalink":"http://yoursite.com/2019/11/13/Android/源码解析/OkHttp3源码-发起请求的主要流程/","excerpt":"OkHttp3源码解析-发起请求的主要流程","text":"OkHttp3源码解析-发起请求的主要流程结合网上的博客和自己看的源码, 写的简单理解. 主要的类: OkHttpClient: 用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等 Request: 用户对单次请求的数据进行配置, uur, 数据参数等. Call: 在框架内部表示对请求的封装 Dispatcher: 在框架内部对请求进行分发 OkHttpClient:主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用. 123456/*** Prepares the &#123;@code request&#125; to be executed at some point in the future.*/@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125; Call:构造方法12345678910111213141516171819private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); this.timeout = new AsyncTimeout() &#123; @Override protected void timedOut() &#123; cancel(); &#125; &#125;; this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);&#125;static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call;&#125; 同步执行一个call在RealCall中有一个execute方法, 这里发起一个同步请求12345678910111213141516171819202122@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this); // getResponseWithInterceptorChain()是具体的请求的操作过程 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; getResponseWithInterceptorChain()方法是请求发出的最终执行方法. 也就是说RealCall中调用execute()就已经直接同步开始了请求操作. 但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? 详细的内容可以看Dispatcher的源码解析. 异步执行一个callRealCall中的enqueue方法, 发起一个异步请求123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类 AsyncCall中的executeOn, execute123456789101112131415161718192021222324252627282930313233343536373839404142/*** Attempt to enqueue this async call on &#123;@code executorService&#125;. This will attempt to clean up* if the executor has been shut down by reporting the call as failed.*/void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\"); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125; &#125;@Override protected void execute() &#123; boolean signalledCallback = false; timeout.enter(); try &#123; Response response = getResponseWithInterceptorChain(); signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; e = timeoutExit(e); if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行. Dispatcher重要的成员变量12345678910111213141516private int maxRequests = 64;private int maxRequestsPerHost = 5;private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */// 这是一个线程池, 并且实现了懒加载private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列. ExcutorService1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp Dispatcher\", false)); &#125; return executorService;&#125; 这个线程池其实是一个CacheThreadPool. 他的特点是: 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列) 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。 适用：执行很多短期异步的小程序或者负载较轻的服务器 检查调用executorService()方法的地方, 是一个promoteAndExecute()方法 enqueue(AsyncCall call)123456void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute();&#125; 上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步 promoteAndExecute()12345678910111213141516171819202122232425262728293031323334353637383940/** * Promotes eligible calls from &#123;@link #readyAsyncCalls&#125; to &#123;@link #runningAsyncCalls&#125; and runs * them on the executor service. Must not be called with synchronization because executing calls * can call into user code. * * @return true if the dispatcher is currently running calls. */// 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call// 如果成功执行上面的操作, 返回trueprivate boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; // 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); // 到达了max限制, break if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); // 在线程池中执行这个call asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; promoteAndExecute()方法的解析直接看上面源码的注释. 结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行.想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢?想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法 finished(Deque calls, T call)12345678910111213private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); idleCallback = this.idleCallback; &#125; boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 在RealCall和AsyncCall代码中, 能看到同样调用了despatcher.finished方法 同步的call1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已.","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"Okhttp3","slug":"Okhttp3","permalink":"http://yoursite.com/tags/Okhttp3/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"docker的使用","slug":"Linux/docker的使用","date":"2019-11-12T08:09:50.000Z","updated":"2019-12-21T12:16:41.879Z","comments":true,"path":"2019/11/12/Linux/docker的使用/","link":"","permalink":"http://yoursite.com/2019/11/12/Linux/docker的使用/","excerpt":"docker 的使用Docker 和 虚拟机的区别:","text":"docker 的使用Docker 和 虚拟机的区别: 实现资源隔离的方式不同: 虚拟机:利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行 Docker:应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值 隔离性:虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker 性能:docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化 Docker Toolbox因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版. Docker Toolbox 添加镜像加速可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题. 可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好 具体的配置修改, 参考:http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox image, containerimage:镜像. 是一个包含有文件系统的面向 Docker 引擎的只读模板. 可以是从远端拉取的, 也可以是自己制作的 container:容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. 注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。 常用操作https://www.runoob.com/docker/docker-container-usage.html很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方 docker container run1docker run -it --name string ubuntu:latest /bin/bash 参数说明: -i: 交互式操作。 -t: 终端。 ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 –name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字 注意image 每一次 docker run 之后, 都会启动一个不同的 container, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令 将容器转化为一个镜像1docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2 -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag 注意 如果要制作的 image 打包上传到自己 docker hub, ‘ / ‘ 前面的用户名需要和自己 docker hub 的用户名保持一致 使用 Dockerfile 创建镜像没试过… 以后有机会再写上","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"handler机制源码解析","slug":"Android/源码解析/handler机制源码解析","date":"2019-11-09T05:59:20.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/11/09/Android/源码解析/handler机制源码解析/","link":"","permalink":"http://yoursite.com/2019/11/09/Android/源码解析/handler机制源码解析/","excerpt":"Handler机制源码解析因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。","text":"Handler机制源码解析因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。 1. Looper主要是loop()方法123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中. // 只有调用quit方法时,next()方法再能真正的返回null return; &#125; try &#123; // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方 msg.target.dispatchMessage(msg); &#125; finally &#123; ... // 省略代码 &#125; msg.recycleUnchecked(); &#125;&#125; 2. MessageQueue关键成员变量12345678910111213141516171819// mPtr是native的MessageQueue的指针private long mPtr; // used by native code// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个messageMessage mMessages;// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();private IdleHandler[] mPendingIdleHandlers;private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;private boolean mQuitting;// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.private boolean mBlocked;// The next barrier token.// Barriers are indicated by messages with a null target whose arg1 field carries the token.private int mNextBarrierToken; 构造方法1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; next()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 调用native层的方法,使用epoll机制,挂起当前线程. // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; // 获取链表的头结点,即第一个message Message msg = mMessages; // 判断msg是否为同步栅栏 // 表示同步栅栏的msg, 其msg.target为null if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. // 寻找队列中第一个异步message do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // 因为上面一旦找到msg,直接return,所以执行到这里已经msg一定为null // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到 // Process the quit message now that all pending messages have been handled. // 判断是否需要结束循环 if (mQuitting) &#123; // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0 // 只有在这里next()方法才会返回null dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. // 当获取到的message为空, 或者message的执行时间没有到 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 1. nativePollOnce(ptr, nextPollTimeoutMillis);这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.nextPollTimeoutMillis = -1 出现的时机两种情况: 消息队列为空 遇到了同步barrier, 并且之后没有遇到异步的msg 2. IdleHandler:1234567891011public static interface IdleHandler &#123; /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次 boolean queueIdle();&#125; MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到) 3. 同步栅栏 Barrier 定义: target为null的msg为同步栅栏 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg 意义: 相当于为msg添加了一个优先级 quit()123456789101112131415161718192021void quit(boolean safe) &#123; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; // 这个方法会去除所有的msg.when &gt; now 的msg removeAllFutureMessagesLocked(); &#125; else &#123; // 没有任何判断, 直接去除所有的msg removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. // 因为在next()方法中才会调用dispose()方法销毁消息队 // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法 nativeWake(mPtr); &#125;&#125; enqueueMessage1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean enqueueMessage(Message msg, long when) &#123; ... // 省略代码 synchronized (this) &#123; if (mQuitting) &#123; msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. // 添加到队列头部, 有可能是需要wake的 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. // 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 1. 插入顺序:之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序 2. needWake判断是否需要唤醒线程.在以下情况下, needWake会为true: 消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1 消息队列不为空, 并且当前线程是blocked的, 新插入msg.when &lt; 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg 消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RemoteView刷新view","slug":"Android/RemoteView刷新View","date":"2019-09-15T08:09:50.000Z","updated":"2019-12-21T12:16:41.876Z","comments":true,"path":"2019/09/15/Android/RemoteView刷新View/","link":"","permalink":"http://yoursite.com/2019/09/15/Android/RemoteView刷新View/","excerpt":"RemoteView刷新View通知栏在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。","text":"RemoteView刷新View通知栏在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。 在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了 关于Intent由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。 在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。 也就是说，Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"RecyclerView全局刷新view避免卡顿","slug":"Android/RecyclerView全局刷新view避免卡顿","date":"2019-09-15T07:33:22.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/09/15/Android/RecyclerView全局刷新view避免卡顿/","link":"","permalink":"http://yoursite.com/2019/09/15/Android/RecyclerView全局刷新view避免卡顿/","excerpt":"RecyclerView全局刷新View避免卡顿","text":"RecyclerView全局刷新View避免卡顿onBindViewHolder(VH holder, int position， List payloads)这个方法默认是调用普通的onBindViewHolder方法。我们可以重写这个方法，在payloads参数为空时，执行默认的onBindViewHolder，在其不为空时，刷新每个item特定的view在调用notifyxxxx类似方法的时候，调用包含payload参数的重载方法 问题：实践了上面的方法，发现卡顿的问题得到了缓解，但是并没有完全解决 创建并操作自己的ViewHolder缓存还是有卡顿的原因：在调用notifyxxxx相关方法时，即使添加了payload参数，依然会有很多item刷新时走onCreateViewHolder方法，在这里进行inflate操作会非常耗时。所以要想办法跳过onCreateViewHolder方法 创建自己的viewholder缓存 创建缓存集合 1private List&lt;ViewHolder&gt; holderList = new ArrayList&lt;&gt;(); 添加到集合 1234holder.itemView.setTag(itemData));if (!holderList.contains(holder)) &#123; holderList.add(holder);&#125; 因为在添加之前做了是否包含的判断，所以集合中按道理之后包含显示的ViewHolder以及缓存的ViewHolder，集合的size并不会无限制的增长。 刷新123456public void update()&#123; for (ViewHolder holder : holderList) &#123; ItemData itemData = (ItemData) holder.itemView.getTag(); // update view &#125;&#125; 卡顿问题解决","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"通知铃声的自定义遇到的问题-根据uri读取文件","slug":"Android/通知铃声的自定义遇到的问题-根据uri读取文件","date":"2019-08-28T15:07:53.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/08/28/Android/通知铃声的自定义遇到的问题-根据uri读取文件/","link":"","permalink":"http://yoursite.com/2019/08/28/Android/通知铃声的自定义遇到的问题-根据uri读取文件/","excerpt":"通知铃声自定义遇到的问题: 根据uri读取文件","text":"通知铃声自定义遇到的问题: 根据uri读取文件问题：在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音 问题根源：1.从系统文件管理器中获取文件，从得到的uri中获取原始路径所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的 网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。 正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。 1InputStream fis = getContentResolver().openInputStream(uri); 2. 将拷贝的文件转化为uri失败的尝试：使用Uri.fromFile():首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。 在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法. 3. grantUriPermission()在某些机型中，使用file自定义notification的声音，仍然不能正常工作。设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning为什么要选择No Filter选项才会看到这个warning。是因为，弹出notification是系统服务，和我们的APP项目不是一个包名在file转uri之后添加一个授权的语句就可以了：12getApplicationContext().grantUriPermission(&quot;com.android.systemui&quot;, Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION); 包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作 到这里问题就解决了","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Notification","slug":"Notification","permalink":"http://yoursite.com/tags/Notification/"},{"name":"Uri","slug":"Uri","permalink":"http://yoursite.com/tags/Uri/"}],"keywords":[]},{"title":"RecyclerView缓存机制总结","slug":"Android/RecyclerView缓存机制总结","date":"2019-08-14T16:31:17.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/08/15/Android/RecyclerView缓存机制总结/","link":"","permalink":"http://yoursite.com/2019/08/15/Android/RecyclerView缓存机制总结/","excerpt":"RecyclerView缓存机制总结基本概念","text":"RecyclerView缓存机制总结基本概念scrapped:A “scrapped” view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse RecyclerView中涉及到缓存的集合 mAttachedScrap 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。 mChangedScrap 显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生 mCachedViews 在屏幕外的Holder。缓存，幕刃大小为2。 mRecyclerPool 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法 mAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。mRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。 RecyclerView获取Holder的顺序(sdk 28) getChangedScrapViewForPosition getScrapOrHiddenOrCachedHolderForPosition getScrapOrCachedViewForId getChildViewHolder mViewCacheExtension.getViewForPositionAndType getRecycledViewPool().getRecycledView mAdapter.createViewHolder 四级缓存 mAttachedScrap mChangedScrap mCacheView mViewCacheExtension mRecyclerPool ListView的缓存机制缓存的集合 mActiveViews 屏幕内的view，可直接重用 mScrapViews 屏幕外的view，需要调用bind 与RecyclerView的不同 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。 RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView） RecyclerView可以实现局部刷新， ListView不行 参考：RecyclerView源码分析缓存机制 RecyclerView的缓存机制 Android ListView 与 RecyclerView 对比浅析–缓存机制","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"事件分发机制","slug":"Android/源码解析/事件分发机制","date":"2019-08-13T13:12:59.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/08/13/Android/源码解析/事件分发机制/","link":"","permalink":"http://yoursite.com/2019/08/13/Android/源码解析/事件分发机制/","excerpt":"事件分发机制dispatchTouchEvent","text":"事件分发机制dispatchTouchEventViewGroup 的 dispatchTouchEvent 方法伪代码1234567891011public boolean dispatchTouchEvent()&#123; boolean consume = false; if (onInterceptTouchEvent(ev))&#123; consume = super.dispatchTouchEvent(); &#125;else&#123; consume = child.dispatchTouchEvent(ev); if (!consume) consume = super.dispatchTouchEvent(ev) &#125; return consume;&#125; 解释：在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理 源代码dispatchTouchEvent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null cancelAndClearTouchTargets(ev); resetTouchState();&#125;// Check for interception.final boolean intercepted;// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素// mFirstTouchTarget赋值在addTouchTarget方法中if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125;.... //省略代码// Check for cancelation.final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;// Update list of touch targets for pointer down, if needed.final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;if (!canceled &amp;&amp; !intercepted) &#123; ... //省略部分代码 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; ... //省略部分代码 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; ... // 省略部分代码 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环 .... // 省略部分代码 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ... //省略代码 &#125; ... // 省略部分代码&#125;... // 省略部分代码// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. // 说明没有子view消费掉这个事件，所以交给父类处理 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; ... // 省略代码&#125; dispatchTransformedTouchEvent12345678910111213141516171819private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理 final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ... // 省略代码&#125; addTouchTargetmFirstTarget 赋值的地方 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 需要注意的点ActionDown ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理 ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位 ActionMove、ActionUp 等其他事件 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理 (以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到) requestDisallowInterceptTouchEvent(true) 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位 View 的 dispatchTouchEvent 方法如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法 123456789101112131415161718public boolean dispatchTouchEvent(MotionEvent event) &#123; ... // 省略代码 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ... // 省略代码 return result;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"LayoutInflater解析","slug":"Android/LayoutInflater解析","date":"2019-08-13T12:31:21.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/08/13/Android/LayoutInflater解析/","link":"","permalink":"http://yoursite.com/2019/08/13/Android/LayoutInflater解析/","excerpt":"LayoutInflater解析源码1View result = root;","text":"LayoutInflater解析源码1View result = root; 12345678910111213// Temp is the root view that was found in the xmlfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);ViewGroup.LayoutParams params = null;if (root != null) &#123; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125;&#125; 123456789101112131415// Inflate all children under temp against its context.rInflateChildren(parser, temp, attrs, true);// We are supposed to attach all the views we found (int temp)// to root. Do that now.if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params);&#125;// Decide whether to return the root that was passed in or the// top view found in xml.if (root == null || !attachToRoot) &#123; result = temp;&#125; 1return result; 使用方法1LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ; 第一个参数是layout资源文件id 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中 需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[]},{"title":"Scale动画组合使用的坑","slug":"Android/Scale动画组合使用的坑","date":"2019-08-02T01:43:37.000Z","updated":"2019-12-21T12:16:41.876Z","comments":true,"path":"2019/08/02/Android/Scale动画组合使用的坑/","link":"","permalink":"http://yoursite.com/2019/08/02/Android/Scale动画组合使用的坑/","excerpt":"Scale动画组合使用的坑API1Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);","text":"Scale动画组合使用的坑API1Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); 参数1: X的初始值参数2: X的最终值参数3: Y的初始值参数4: Y的最终值参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放参数6: X轴缩放轴点，1f表示以View的最右端为轴点参数7: Y轴，同参数5参数8: Y轴，同参数6 问题一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小1234567891011121314// start animation AnimationSet animationSet = new AnimationSet(false); Animation alpha = new AlphaAnimation(0, 100); alpha.setDuration(80); Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); scale.setDuration(160); scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f)); Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); scale2.setDuration(70); scale2.setStartOffset(160); animationSet.addAnimation(scale); animationSet.addAnimation(scale2); animationSet.addAnimation(alpha); tv.startAnimation(animationSet); 但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小 原因scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子123Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);scale2.setDuration(70);scale2.setStartOffset(160);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"ThreadLocal","slug":"Java/ThreadLocal","date":"2019-07-22T05:57:12.000Z","updated":"2019-12-21T12:16:41.879Z","comments":true,"path":"2019/07/22/Java/ThreadLocal/","link":"","permalink":"http://yoursite.com/2019/07/22/Java/ThreadLocal/","excerpt":"ThreadLocal作用当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量","text":"ThreadLocal作用当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量 源码分析set()12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; createMap()方法：123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 查看Thread类的代码：123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value get()方法12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 其中的ThreadLocalMap.Entry123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己 总结Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://yoursite.com/categories/java/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://yoursite.com/categories/java/多线程/"}]},{"title":"Text相关计算","slug":"Android/Text相关计算","date":"2019-07-19T03:09:42.000Z","updated":"2020-02-19T02:53:42.328Z","comments":true,"path":"2019/07/19/Android/Text相关计算/","link":"","permalink":"http://yoursite.com/2019/07/19/Android/Text相关计算/","excerpt":"Text相关计算Text的相关属性Baseline上方的值为正，下方的值为负","text":"Text相关计算Text的相关属性Baseline上方的值为正，下方的值为负 TextSize和TextView大小的转换相关参数包括： ascent/descent属性 top/bottom参数 禁止includePadding时, TextView实际占据高度是 (ascent - descent) / UPM * textSize 开启includePadding时, TextView实际占据高度是 (top - bottom) / UPM * textSize 参考Paint 绘制文字属性TextView文字实际高度分析","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RecyclerView设置item的间距","slug":"Android/RecyclerView设置item的间距","date":"2019-07-09T09:29:55.000Z","updated":"2019-12-21T12:16:41.876Z","comments":true,"path":"2019/07/09/Android/RecyclerView设置item的间距/","link":"","permalink":"http://yoursite.com/2019/07/09/Android/RecyclerView设置item的间距/","excerpt":"RecyclerView设置item的间距","text":"RecyclerView设置item的间距关于GridLayoutManager当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，实际上就是将屏幕均分为四份，每一份都是180px宽（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。 自定义ItemDecorationgetItemOffsets方法设置ItemView的内嵌偏移长度 ItemView 外面会包裹着一个矩形（outRect）内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔相当于为item添加了padding 常用的getItemOffsets的计算 123456789101112131415161718192021222324252627282930313233343536373839// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等public class EmojiItemDecoration extends RecyclerView.ItemDecoration &#123; private int mNumColumn; private int mVerticalSpacing; private int mItemWidth; private int mItemHorizontalSpacing; private boolean mInitSpacing = false; public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) &#123; mNumColumn = column; mItemWidth = itemWidth; mVerticalSpacing = verticalSpacing; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if (!mInitSpacing) &#123; mInitSpacing = true; int parentWidth = parent.getWidth(); mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1); &#125; int position = parent.getChildAdapterPosition(view); int column = position % mNumColumn; outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn; outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn; if (position &lt; mNumColumn) &#123; outRect.top = Dimensions.pxFromDp(12); &#125; if (position &gt;= mNumColumn) &#123; outRect.top = mVerticalSpacing; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"startService()和bindService()","slug":"Android/startService-和bindService","date":"2019-07-04T12:37:58.000Z","updated":"2019-12-21T12:16:41.876Z","comments":true,"path":"2019/07/04/Android/startService-和bindService/","link":"","permalink":"http://yoursite.com/2019/07/04/Android/startService-和bindService/","excerpt":"startService()和bindService()的区别","text":"startService()和bindService()的区别 生命周期上的差别startService()执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。 多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。无论startService调用多少次，stopService只需要调用一次就能够终止Service BindService()bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。 onBind返回值是null调用bindService开启服务，生命周期执行的方法依次是：onCreate() ==&gt; onBind();调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。 onBind返回值不为null这时候调用bindService开启服务，生命周期执行的方法依次是：onCreate() ==&gt; onBind() ==&gt; onServiceConnected();可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。总结第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。 既使用startService又使用bindService的情况如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。 参考链接:https://my.oschina.net/tingzi/blog/376545https://www.jianshu.com/p/d870f99b675c","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"}],"tags":[{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"}]},{"title":"scrollBy(),scrollTo()和Scroller","slug":"Android/scrollBy-scrollTo-和Scroller","date":"2019-06-16T12:26:14.000Z","updated":"2019-12-21T12:16:41.876Z","comments":true,"path":"2019/06/16/Android/scrollBy-scrollTo-和Scroller/","link":"","permalink":"http://yoursite.com/2019/06/16/Android/scrollBy-scrollTo-和Scroller/","excerpt":"scrollBy(),scrollTo()和Scroller","text":"scrollBy(),scrollTo()和Scroller作用用于对View进行滚动注意： 滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）比如：TextView滚动的是内部的text而不是整个view 滚动的方向与坐标轴正方向相反比如：scrollBy(20,0)最后显示，view会向左移动因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码) scrollBy() 和 scrollTo()的区别scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。 Scroller利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移 使用步骤Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤： 创建Scroller的实例 调用startScroll()方法来初始化滚动数据并刷新界面 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 代码：实现自定义的简单ViewPager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.example.work3;import android.content.Context;import android.support.v4.view.ViewConfigurationCompat;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.widget.Scroller;public class ScrollLayout extends ViewGroup &#123; private final String TAG = \"test_scroll\"; private Scroller mScroller; // 可以判定为拖动的最小滑动距离 private int mTouchSlop; // 落下的屏幕坐标 private float mXDown; // 当前的屏幕坐标 private float mXMove; // 上一次Action_MMOVE的屏幕坐标 private float mLastMove; // 界面可滑动的左边界 private int mLeftBorder; // 界面可滑动的右边界 private int mRightBorder; public ScrollLayout(Context context) &#123; super(context); init(context); &#125; public ScrollLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; mScroller = new Scroller(context); // 获取系统定义的mTouchSlop值 mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context)); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (!changed) return; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight()); &#125; // 初始化左右边界 mLeftBorder = getChildAt(0).getLeft(); mRightBorder = getChildAt(childCount - 1).getRight(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mXDown = ev.getRawX(); mLastMove = mXDown; break; case MotionEvent.ACTION_MOVE: mXMove = ev.getRawX(); float diff = Math.abs(mXMove - mXDown); mLastMove = mXMove; // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件 if (diff &gt; mTouchSlop) &#123; return true; &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: &#123; mXMove = event.getRawX(); int scrolledX = (int) (mLastMove - mXMove); if (getScrollX() + scrolledX &lt; mLeftBorder) &#123; scrollTo(mLeftBorder, 0); return true; &#125; else if (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123; scrollTo(mRightBorder - getWidth(), 0); return true; &#125; // view随着手指的拖动进行滚动 scrollBy(scrolledX, 0); Log.i(TAG, \"onTouchEvent: \" + getChildAt(1).getLeft()); mLastMove = mXMove; break; &#125; case MotionEvent.ACTION_UP: &#123; // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面 int targetIndex = (getScrollX() + getWidth() / 2) / getWidth(); int dx = targetIndex * getWidth() - getScrollX(); // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面 mScroller.startScroll(getScrollX(), 0, dx, 0); // 对view重绘 invalidate(); break; &#125; &#125; return super.onTouchEvent(event); &#125; @Override public void computeScroll() &#123; // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 对view重绘 invalidate(); &#125; &#125;&#125; getScrollX()方法返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。原点（0，0）是初始化时内容显示的位置。 参考Android getScrollX()详解 Android Scroller完全解析，关于Scroller你所需知道的一切","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"mysql配置相关","slug":"Linux/mysql配置相关","date":"2019-05-04T03:04:44.000Z","updated":"2019-12-21T12:16:41.880Z","comments":true,"path":"2019/05/04/Linux/mysql配置相关/","link":"","permalink":"http://yoursite.com/2019/05/04/Linux/mysql配置相关/","excerpt":"1. 尽量使用MariaDB而不是mysql","text":"1. 尽量使用MariaDB而不是mysql之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了 而且，mysql的命令行终端很明显有bug，没有MariaDB好用 2. MariaDB更新密码mariadb的安装可以查看官网，上面有yum安装的教程。安装之后默认是没有密码的。需要更新密码。另外，发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的 中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps 1. mysql_secure_installation 命令安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码 2. 登陆mysql更改密码12345678# 2.1 更新 mysql 库中 user 表的字段：use mysql; UPDATE user SET password=password('newpassword') WHERE user='root'; flush privileges; exit; # 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法SET password for 'root'@'localhost'=password('newpassword'); 3. mysql配置远程登录1. 给用户远程登录权限：12345use mysqlupdate user set host='%' where user ='root';FLUSH PRIVILEGES;grant all privileges on *.* to root@'%' identified by \"password\";FLUSH PRIVILEGES; root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码 使用以下命令可以查看用户的登录权限 1select host,user,password,plugin from user; 注意root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。可以使用如下命令更改加密方式： 1update user set plugin='mysql_native_password' where user='root'; 2. lnmp环境配置iptableslnmp一键安装环境默认是禁用iptables远程登录的， 查看iptables规则：1iptables -L -n --line-numbers 输入样例如下：可以看到3306端口的target为drop 删除对应的drop规则 1iptables -D INPUT 5 iptables的使用参考：https://www.vpser.net/security/linux-iptables.html 3.非集成centos环境开放3306端口centos-7以上firewalld 防火墙（centos-7）运行命令,并重启： 12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload centos-7以前iptables 防火墙（centos6.5及其以前）运行命令 1vim /etc/sysconfig/iptables 在文件内添加下面命令行，然后重启 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 1service iptables restart","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"apt常用命令","slug":"Linux/apt常用命令","date":"2019-05-02T11:49:35.000Z","updated":"2019-12-21T12:16:41.879Z","comments":true,"path":"2019/05/02/Linux/apt常用命令/","link":"","permalink":"http://yoursite.com/2019/05/02/Linux/apt常用命令/","excerpt":"apt常用命令参考：apt命令安装指定版本","text":"apt常用命令参考：apt命令安装指定版本 更新 sudo apt-get update //更新源sudo apt-get upgrade //更新已安装的包sudo apt-get dist-upgrade //升级系统sudo apt-get dselect-upgrade //使用 dselect 升级 查询 apt-cache search package//搜索包 apt-cache show package//获取包的相关信息，如说明、大小、版本等 apt-cache depends package//了解使用依赖apt-cache rdepends package//是查看该包被哪些包依赖 12345apt-cache madison &lt;package name&gt; //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。apt-cache policy &lt;&lt;package name&gt;&gt; /*将列出所有来源的版本。信息会比上面详细一点*/apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。 安装 sudo apt-get install package//安装包 sudo apt-get install package - - reinstall//重新安装包 sudo apt-get -f install//修复安装 (“-f = ——fix-missing”) 删除sudo apt-get remove package删除包 sudo apt-get remove package - - purge删除包，包括删除配置文件等sudo apt-get clean &amp;&amp; sudo apt-get autoclean清理无用的包sudo apt-get check检查是否有损坏的依赖 其他 sudo apt-get build-dep package安装相关的编译环境apt-get source package下载该包的源代码","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[]},{"title":"华为手机的内存泄露","slug":"Android/华为手机的内存泄露","date":"2019-04-19T03:41:06.000Z","updated":"2019-12-21T12:16:41.876Z","comments":true,"path":"2019/04/19/Android/华为手机的内存泄露/","link":"","permalink":"http://yoursite.com/2019/04/19/Android/华为手机的内存泄露/","excerpt":"华为手机的内存泄露最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。","text":"华为手机的内存泄露最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。 我的手机系统是华为EMUI9.0 &amp;&amp; Android9.0 以下是我找到的网上的解决方案： 参考链接https://www.jianshu.com/p/95242060320f inputMethodManager.mLastSrvView泄露123456789101112131415161718192021222324252627282930313233public class FixMemLeak &#123; private static Field field; private static boolean hasField = true; public static void fixLeak(Context context) &#123; if (!hasField) &#123; return; &#125; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); if (imm == null) &#123; return; &#125; String[] arr = new String[]&#123;\"mLastSrvView\"&#125;; for (String param : arr) &#123; try &#123; if (field == null) &#123; field = imm.getClass().getDeclaredField(param); &#125; if (field == null) &#123; hasField = false; &#125; if (field != null) &#123; field.setAccessible(true); field.set(imm, null); &#125; &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;&#125; 在BaseActivity的onDestroy()方法里执行这个fexLeak()方法，然后所有的Activity继承BaseActivity。然后就没有报错了 Toast$TN.mWM 泄露泄露出现在显示一个Toast之后。这个就更迷了，网上我没有找到相关的解释。同样的在模拟器上没有出现这样的内存泄露。 最终的解决方法是：在使用Toast时，传入的Context参数使用ApplicationContext而不是Activity。然后就没有内存泄露报出了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"内存泄露","slug":"内存泄露","permalink":"http://yoursite.com/tags/内存泄露/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Activity class {} does not exist","slug":"Android/Activity-class-does-not-exist","date":"2019-04-16T11:23:35.000Z","updated":"2019-12-21T12:16:41.873Z","comments":true,"path":"2019/04/16/Android/Activity-class-does-not-exist/","link":"","permalink":"http://yoursite.com/2019/04/16/Android/Activity-class-does-not-exist/","excerpt":"Activity class {} does not exist","text":"Activity class {} does not exist有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。 解决办法：使用adb命令1adb uninstall [包名] 估计可能是调试的APP没有彻底卸载造成的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AndroidStudio","slug":"Android/AndroidStudio","permalink":"http://yoursite.com/categories/Android/AndroidStudio/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://yoursite.com/tags/AndroidStudio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AndroidStudio","slug":"Android/AndroidStudio","permalink":"http://yoursite.com/categories/Android/AndroidStudio/"}]},{"title":"MVP模式防止内存泄露","slug":"Android/MVP模式防止内存泄露","date":"2019-04-15T00:54:27.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/04/15/Android/MVP模式防止内存泄露/","link":"","permalink":"http://yoursite.com/2019/04/15/Android/MVP模式防止内存泄露/","excerpt":"MVP模式防止内存泄露参考链接https://jocherch.github.io/mvp/mvp-memory-leak/https://blog.csdn.net/Xiong_IT/article/details/52610729","text":"MVP模式防止内存泄露参考链接https://jocherch.github.io/mvp/mvp-memory-leak/https://blog.csdn.net/Xiong_IT/article/details/52610729 发生内存泄露的原因由于Presenter经常性地需要执行一些耗时的操作，例如，我们经常使用的网络请求数据。当 Presenter 持有了 Activity 的强引用，如果在请求结束之前，Activity 被销毁了，那么由于网络请求还没有返回，导致 Presenter 一直持有 Activity 对象的引用，使得该对象无法被系统回收，此时就发生了内存泄露。 解决方案：通过弱引用和 Activity / Fragment 的生命周期来解决这个问题。 Model12345interface BaseMvpModel&#123; public void mvpCancleTasks(); // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api &#125; View123456789101112interface BaseMvpView&#123; public void mvpDetachView(); /* 例如 @Override public void onDestroy() &#123; super.onDestroy(); mPresenter.mvpDestroy(); mPresenter = null; &#125; */&#125; Presenter123456789101112interface BaseMvpPresenter&#123; public void mvpDestory(); /*例如: public void mvpDestory() &#123; view = null; if(modle != null) &#123; modle.mvpaCncleTasks(); modle = null; &#125; &#125; */&#125; 这里只是创建了一个BaseInterface用于让mvp的接口去继承，没有做更加详细的封装，仅仅由于提示。主要是不同的模块处理可能会有不同的操作 注意要使用WeakReference并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"内存泄露","slug":"内存泄露","permalink":"http://yoursite.com/tags/内存泄露/"},{"name":"MVP","slug":"MVP","permalink":"http://yoursite.com/tags/MVP/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Activity管理类的封装","slug":"Android/Activity管理类的封装","date":"2019-04-14T11:41:50.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/04/14/Android/Activity管理类的封装/","link":"","permalink":"http://yoursite.com/2019/04/14/Android/Activity管理类的封装/","excerpt":"使用场景有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的","text":"使用场景有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的 我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class FinishActivityManager extends BaseActivity &#123; private FinishActivityManager() &#123; &#125; private static FinishActivityManager sManager; private Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack; public static FinishActivityManager getManager() &#123; if (sManager == null) &#123; synchronized (FinishActivityManager.class) &#123; if (sManager == null) &#123; sManager = new FinishActivityManager(); &#125; &#125; &#125; return sManager; &#125; /** * 添加Activity到栈 * @param activity */ public void addActivity(Activity activity) &#123; if (mActivityStack == null) &#123; mActivityStack = new Stack&lt;&gt;(); &#125; mActivityStack.add(new WeakReference&lt;&gt;(activity)); &#125; /** * 检查弱引用是否释放，若释放，则从栈中清理掉该元素 */ public void checkWeakReference() &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); if (temp == null) &#123; it.remove(); &#125; &#125; &#125; &#125; /** * 获取当前Activity（栈中最后一个压入的） * @return */ public Activity currentActivity() &#123; checkWeakReference(); if (mActivityStack != null &amp;&amp; !mActivityStack.isEmpty()) &#123; return mActivityStack.lastElement().get(); &#125; return null; &#125; /** * 关闭当前Activity（栈中最后一个压入的） */ public void finishActivity() &#123; Activity activity = currentActivity(); if (activity != null) &#123; finishActivity(activity); &#125; &#125; /** * 关闭指定的Activity * @param activity */ public void finishActivity(Activity activity) &#123; if (activity != null &amp;&amp; mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); // 清理掉已经释放的activity if (temp == null) &#123; it.remove(); continue; &#125; if (temp == activity) &#123; it.remove(); &#125; &#125; activity.finish(); &#125; &#125; /** * 关闭指定类名的所有Activity * @param cls */ public void finishActivity(Class&lt;?&gt; cls) &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity activity = activityReference.get(); // 清理掉已经释放的activity if (activity == null) &#123; it.remove(); continue; &#125; if (activity.getClass().equals(cls)) &#123; it.remove(); activity.finish(); &#125; &#125; &#125; &#125; /** * 结束所有Activity */ public void finishAllActivity() &#123; if (mActivityStack != null) &#123; for (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123; Activity activity = activityReference.get(); if (activity != null) &#123; activity.finish(); &#125; &#125; mActivityStack.clear(); &#125; &#125; /** * 退出应用程序 */ public void exitApp() &#123; try &#123; finishAllActivity(); // 退出JVM,释放所占内存资源,0表示正常退出 System.exit(0); // 从系统中kill掉应用程序 android.os.Process.killProcess(android.os.Process.myPid()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后是一个BaseActivity类， 重写onCreate和onDestory方法 1234567891011121314151617181920212223242526package com.example.chenlei.test;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.util.Log;public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyActivityManager.addActivity(this); Log.i(\"有activity新添加\", \"onCreate: \"); &#125; @Override protected void onDestroy() &#123; Log.i(\"有activity被销毁\", \"onDestroy: \"+ MyActivityManager.getSize()); MyActivityManager.finishActivity(this); super.onDestroy(); &#125;&#125; 接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作 网上原文：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android-Studio解决依赖冲突","slug":"Android/Android-Studio解决依赖冲突","date":"2019-04-14T11:40:23.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/04/14/Android/Android-Studio解决依赖冲突/","link":"","permalink":"http://yoursite.com/2019/04/14/Android/Android-Studio解决依赖冲突/","excerpt":"Android-Studio解决依赖冲突我们做android项目通常会引入很多第三方库， 有时候不同的第三方库会出现依赖冲突，导致添加依赖后就android-studio就报错。做项目是要添加glide库，直接添加最新版本 4.8，《第一行代码》中介绍使用的版本是3.7。 结果就是4.8的版本一添加依赖就报错，在build.gradle文件中报错buildtool版本冲突。我在网上找到了如下的文章，解决方法是一样的，做一个笔记。需要说明的 glide4.+ 的版本和 3.+ 的版本，提供的api接口的操作形式发生了变化，而且google上搜到说版本升级之后其实性能没有多大提升","text":"Android-Studio解决依赖冲突我们做android项目通常会引入很多第三方库， 有时候不同的第三方库会出现依赖冲突，导致添加依赖后就android-studio就报错。做项目是要添加glide库，直接添加最新版本 4.8，《第一行代码》中介绍使用的版本是3.7。 结果就是4.8的版本一添加依赖就报错，在build.gradle文件中报错buildtool版本冲突。我在网上找到了如下的文章，解决方法是一样的，做一个笔记。需要说明的 glide4.+ 的版本和 3.+ 的版本，提供的api接口的操作形式发生了变化，而且google上搜到说版本升级之后其实性能没有多大提升 原文：https://blog.csdn.net/victor888886/article/details/73714141 以下是网上的文章内容：最近刚接手一个项目，里面模块有三四个，引入的第三方包更多了。但是问题来了，新配置的studio一运行就报了错。 Error:Execution failed for task &apos;:app:processDebugManifest&apos;. Manifest merger failed : Attribute meta-data#android.support.VERSION@value value=(25.3.1) from [com.android.support:design:25.3.1] AndroidManifest.xml:27:9-31is also present at [com.android.support:support-v4:26.0.0-alpha1] AndroidManifest.xml:27:9-38 value=(26.0.0-alpha1).Suggestion: add ‘tools:replace=”android:value”’ to element at AndroidManifest.xml:25:5-27:34 to override. 可以看到，studio已经明确的指出了错误，在清单文件中Android support 库版本冲突了，而且，studio还很“人性”地给出了suggestion：清单文件25行——27行添加： tools:replace=&quot;android:value&quot; 坑就坑在这里，给出的建议完全误导人了。咳咳，下面看我详（如）细（何）解（装）释（逼）： 问题分析：看到com.android.support:design:25.3.1 和 com.android.support:support-v4:26.0.0-alpha1， 说明这个Android support库版本冲突了，解决的思想很简单，就是统一使用同一个版本的support库，比如修改掉26.0.0-alpha1的依赖，统一换成25.3.1的版本。 解决既然有了思路，那就动手试一试，全局搜索26.0.0-alpha1，统一替换为 25.3.1 正常情况下，这个是能解决问题的，但只能解决gradle里面自己引入的依赖版本问题。然而，今天碰到的坑还没完呢，同步代码以后，还是原来的错误信息！ 再次分析：问题就出在第三方库的依赖了，好多第三方库默认引用当前最新的support库，现在最新的就是26.0.0-alpha1这个版本。所以，要解决问题，就要从引入的三方库里面入手了！那么问题来了，挖掘机哪家......哦不，怎么知道哪个依赖包有冲突？下面出杀手锏了： 打开Android studio下面的terminal，输入命令：`gradle -q app:dependencies`,惊喜出现了：没有配置gradle环境变量的同学赶快去配一个吧！.. **（这里不需要配置gradle环境变量也可以，在terminal中输入命令：./gradlew -q app:dependencies效果是一样的）** 配过之后可以看到类似一下的输出： +— project :base-util| +— com.android.support:recyclerview-v7:25.3.1 ()| +— cn.qqtheme.framework:WheelPicker:1.5.1| | +— cn.qqtheme.framework:Common:1.5.1| | | +— com.android.support:support-v4:latest.release -&gt; 26.0.0-alpha1 ()| | | — com.android.support:support-annotations:latest.release -&gt; 26.0.0-alpha1| | +— com.android.support:support-v4:latest.release -&gt; 26.0.0-alpha1 ()| | — com.android.support:support-annotations:latest.release -&gt; 26.0.0-alpha1| +— com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.9.8| +— io.reactivex:rxjava:1.1.8| +— io.reactivex:rxandroid:1.1.0| | — io.reactivex:rxjava:1.1.0 -&gt; 1.1.8| +— com.squareup.okhttp3:okhttp:3.2.0 -&gt; 3.4.1| | — com.squareup.okio:okio:1.9.0| +— com.squareup.retrofit2:retrofit:2.0.2| | — com.squareup.okhttp3:okhttp:3.2.0 -&gt; 3.4.1 ()| +— com.squareup.retrofit2:adapter-rxjava:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — io.reactivex:rxjava:1.1.1 -&gt; 1.1.8| +— com.squareup.retrofit2:converter-gson:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — com.google.code.gson:gson:2.6.1| +— com.squareup.okhttp3:logging-interceptor:3.4.1| | — com.squareup.okhttp3:okhttp:3.4.1 ()| +— com.github.zhaokaiqiang.klog:library:1.5.0| | — com.android.support:support-annotations:23.4.0 -&gt; 26.0.0-alpha1| +— com.squareup.retrofit2:converter-simplexml:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — org.simpleframework:simple-xml:2.7.1| +— com.github.bumptech.glide:glide:3.7.0| +— project :base-res (*)| — com.jakewharton:butterknife:7.0.1 很明显cn.qqtheme.framework:WheelPicker这个包默认引用了最新的support库！ 最终解决：找到依赖的库，修改为下面的方式引入： compile (&apos;cn.qqtheme.framework:WheelPicker:1.5.1&apos;){ exclude group:&apos;com.android.support&apos; }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AndroidStudio","slug":"Android/AndroidStudio","permalink":"http://yoursite.com/categories/Android/AndroidStudio/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://yoursite.com/tags/AndroidStudio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AndroidStudio","slug":"Android/AndroidStudio","permalink":"http://yoursite.com/categories/Android/AndroidStudio/"}]},{"title":"Handler防止内存泄露","slug":"Android/Handler防止内存泄露","date":"2019-04-14T10:59:55.000Z","updated":"2019-12-21T12:16:41.874Z","comments":true,"path":"2019/04/14/Android/Handler防止内存泄露/","link":"","permalink":"http://yoursite.com/2019/04/14/Android/Handler防止内存泄露/","excerpt":"Handler防止内存泄露1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(\"\"); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; //loadData()方法是在子线程中，执行 private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //如果你的Handler被delay（延时了）,可以做如下的处理 mHandler.removeCallbacksAndMessages(null); &#125;&#125;","text":"Handler防止内存泄露1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(\"\"); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; //loadData()方法是在子线程中，执行 private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //如果你的Handler被delay（延时了）,可以做如下的处理 mHandler.removeCallbacksAndMessages(null); &#125;&#125; 解释创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息 使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://yoursite.com/tags/内存泄露/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Jni入门","slug":"Java/Jni入门","date":"2019-04-13T05:12:47.000Z","updated":"2019-12-21T12:16:41.879Z","comments":true,"path":"2019/04/13/Java/Jni入门/","link":"","permalink":"http://yoursite.com/2019/04/13/Java/Jni入门/","excerpt":"Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki","text":"Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki 1、编写native方法，使用javah创建头文件123public class HelloWorld &#123; public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现&#125; 1javah -jni -classpath JniCalcINterface 参数说明：classpath：类搜索路径，这里表示从当前的 bin 目录下查找d：将生成的头文件放到当前的 jni 目录下o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h） 注意：-d和-o只能使用其中一个参数。 创建的.h文件如下123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern \"C\" &#123; #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus &#125; #endif #endif **注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面 3、编译出so文件1gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 参数含义: -L 表示要链接的库所在的目录。-L. 表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。 -l (L的小写) 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test -include 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。 -I (i 的大写) 指定头文件的所在的目录，可以使用相对路径。 -shared 指定生成动态链接库 -fPIC 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。 -o 指定编译后动态库生成的路径和文件名 4、加载动态库1234static&#123; System.loadLibrary(\"HelloWorld\"); //方式一 System.load(\"/Users/yangxin/Desktop/libHelloWorld.jnilib\" //方式二);&#125; 方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀方式2：指定动态库的绝对路径名，需要加上前缀和后缀 推荐使用这种方法 如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。 5、运行java程序","categories":[],"tags":[{"name":"jni","slug":"jni","permalink":"http://yoursite.com/tags/jni/"}],"keywords":[]},{"title":"自定义ViewGroup","slug":"Android/自定义ViewGroup","date":"2019-04-13T05:12:35.000Z","updated":"2019-12-21T12:16:41.878Z","comments":true,"path":"2019/04/13/Android/自定义ViewGroup/","link":"","permalink":"http://yoursite.com/2019/04/13/Android/自定义ViewGroup/","excerpt":"自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁）","text":"自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁） 下面是继承自ViewGroup的FlowLayout标签流式布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.example.test;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.view.ViewGroup;public class FlowLayout extends ViewGroup &#123; public FlowLayout(Context context) &#123; super(context); &#125; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int specWidth = MeasureSpec.getSize(widthMeasureSpec); int specHeight = MeasureSpec.getSize(heightMeasureSpec); int specWidthMode = MeasureSpec.getMode(widthMeasureSpec); int specHeightMode = MeasureSpec.getMode(heightMeasureSpec); int count = getChildCount(); //计算child的大小 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0 //这里为了支持margin，所以用measureChildWithMargins方法 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); &#125; //计算ViewGroup自身的大小 //这里只要处理height的wrap_content情况就可以了 int height = specHeight; int width = specWidth; if (specHeightMode == MeasureSpec.AT_MOST) &#123; height = getPaddingBottom() + getPaddingTop(); int used_width = 0; int line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams(); int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //在这一行可以容纳 if (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123; line_max_height = Math.max(line_max_height, child_height); used_width += child_width; &#125; else &#123; //切换到下一行 height += line_max_height; used_width = child_width; line_max_height = child_height; &#125; &#125; //加上最后一行的最大height height += line_max_height; &#125; setMeasuredDimension(width, height); &#125; private final String TAG = \"test_log\"; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd(); int used_width = 0; int used_height = 0; int count = getChildCount(); int last_line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child_view = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams(); //用于计算是否越界时需要包含margin int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //layout时的位置，必须考虑padding int layout_l, layout_t, layout_r, layout_b; if (used_width + child_width &lt;= width) &#123; layout_l = getPaddingStart() + used_width + mlp.leftMargin; layout_t = getPaddingTop() + used_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_width += child_width; //记录该行height的最大值 last_line_max_height = Math.max(last_line_max_height, child_height); &#125; else &#123; layout_l = getPaddingStart() + mlp.leftMargin; layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_height += last_line_max_height; used_width = child_width; last_line_max_height = child_height; &#125; child_view.layout(layout_l, layout_t, layout_r, layout_b); &#125; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(super.generateDefaultLayoutParams()); &#125;&#125; 关于MeasureSpec父控件告诉子控件可获得的空间以及关于这个空间的约束条件 SpecMode EXACTLY 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式 AT_MOST width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值 UNSPECIFIED 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用 关于view的Measure过程我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。 这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程： ViewRootImpl.performTraversals()-&gt;performMeasure(): 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量 DecorView.measure()-&gt;onMeasure(): DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量 ViewGroupA.measure()-&gt;onMeasure(): 这是我们自定义的一个ViewGroup(继承自ViewGroup)假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。 所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。 ViewB.measure()-&gt;onMeasure(): View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。 测量子view时MeasureSpec的生成规则 当子View的宽高设置的是具体数值时 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。 当子View的宽高设置的是match_parent 则不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED） 当子View的宽高设置的是wrap_content, 因为这种情况父容器实在不知道子View应该多宽多高，所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。 关于LayoutParams在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。在使用中必须重写所有的generateLayoutParams()方法尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"多个cpp文件编译共享同一个.h文件的全局变量","slug":"C/多个cpp文件编译共享同一个-h文件的全局变量","date":"2019-04-13T05:12:22.000Z","updated":"2019-12-21T12:16:41.879Z","comments":true,"path":"2019/04/13/C/多个cpp文件编译共享同一个-h文件的全局变量/","link":"","permalink":"http://yoursite.com/2019/04/13/C/多个cpp文件编译共享同一个-h文件的全局变量/","excerpt":"多个cpp文件编译共享同一个.h文件的全局变量","text":"多个cpp文件编译共享同一个.h文件的全局变量在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案: 一个cpp文件多次#include一个.h文件 使用#ifndef 12345//在.h头文件中#ifndef &lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写#define &lt;标示&gt;//...头文件内容#endif 原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容 这种方法只能解决一个cpp源文件中的重复include问题 多个cpp文件多次#include一个.h文件使用static关键字123//.h头文件static int i;static void func(); static修饰变量变量static标记之后，多个cpp文件include不会出现问题。但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的下面是网上的一些解释: 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。 static修饰函数函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。似乎是这样的。。。我的理解。网上说static和inline经常配合使用 使用extern关键字extern表明该变量在别的地方已经定义过了，在这里要使用那个变量 12//cpp文件extern int i; 经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。 定义在.h文件的情况下，在使用extern时，不能include定义它的.h文件。否则还是会出现重定义的问题。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}],"tags":[],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}]},{"title":"C语言结构体的内存对齐","slug":"C/C语言结构体的内存对齐","date":"2019-04-13T05:11:14.000Z","updated":"2019-12-21T12:16:41.879Z","comments":true,"path":"2019/04/13/C/C语言结构体的内存对齐/","link":"","permalink":"http://yoursite.com/2019/04/13/C/C语言结构体的内存对齐/","excerpt":"C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍","text":"C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍 pragram pack(4)设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节 例子：123456789101112131415# pragram pack(8)struct S3&#123; double d; char c; int i;&#125;;struct S4&#123; char c1; struct S3 s3; double d;&#125;;printf(\"%d\\n\", sizeof(struct S4)); 最后的输出为 32 参考：[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园 C语言联合体union的sizeof分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}],"tags":[],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}]}]}